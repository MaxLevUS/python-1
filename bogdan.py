# # print("Maksim Hello")
# # my_list = [1, 2, 3]


# # print(my_list)


# """long_str = "This is a
# very
# long string"

# print("1) " + long_str)

# print("2) ", type(long_str))

# print("3) ", len(long_str))

# print("4) ", long_str[0])

# print("5) " + long_str[0:6])

# print("6) " + long_str[3:])"""


# # Methods

# """my_new_string = "Hello, My name is Maksim"

# print(my_new_string)

# print(my_new_string.replace("Maksim", "Anastasiya"))

# print(my_new_string.count(" "))

# print(my_new_string.count("is"))"""


# # Целые числа


# """friend_qty = 50

# print(friend_qty)

# print(type(friend_qty))


# any_num = input("Enter any number: ")

# print(any_num)

# print(type(any_num))  # type will be - str


# int_num = int(input("Insert any number: "))

# print(int_num)

# print(type(int_num))  # type will be - number"""


# # Возведение в степень

# base = 5
# power = 3

# print(pow(base, power))


# # Длинные числа - разрешены нижние подчеркивания, для удобства чтения, но при выводе они не учитываются

# """one_million = 1_000_000

# print(one_million)  # 1000000

# my_number = 3_427

# print(my_number)  # 3427"""

# # Задача

# """input_str = input("Insert any number  ")
# input_int = int(input_str)

# print(input_int)

# print(type(input_int))"""


# first_num = 5
# second_num = 10

# print(pow(first_num, second_num))
# print(type(pow(first_num, second_num)))


# Самое важное в Пайтон это Объекты,
# потому что Пайтон это объектно-ориентированный язык программирования
# Почему не совсем видно, что Пайтон это ООП, потому что
# непосредственно написание кода, очень сильно обстрагированно,
# что происходит внутри Пайтона.

# Главное, что все сущности в Пайтон это Объекты - экземпляры
# того или иного класса. Это означает, что если мы создаем числа,
# то в Пайтоне есть для этого определенный класс, на основании
# которого создаются экземпляры класса.

# А, Класс это шаблон или прототип для создания Объектов.
# И, получается, что на основании одного класса можно создавать
# много Объектов. К примеру клас int(1), но на его основании можно
# создать много разных экземпляров чисел и эти экземпляры будут
# независимы друг от друга.

# У каждого Объекта есть атрибуты, при этом атрибут объекта,
# называется Методом, если его значение - Функция. Следовательно
# Метод можно вызвать как и Любую Функцию.

# Основные типы в Пайтон:

# str("Строки")

# int(10) = Целое число, 0 также целое число.

# bool = имеет только два значения True or False

# list[1, 2, 3, 5] = Список = можно сохранять эл. разных типов,
# где после запятой обычно ставят пробел.

# dict{'min': 5, 'max': 8} = Словарь, все словари создаются на
# основании класса dict. создается пара Ключ: Значение. Названия
# ключей должны находиться между одинарными или же двойными ковычками.

# list(СПИСОК) = изменяемые, важен порядок эл. и следовательно
# у каждого эл. есть свой уникальный индекс и в списках допускаются
# одинаковые эл. (ИЗМЕНЯЕМЫЕ, УПОРЯДОЧЕННЫЕ, ДОПУСТИМЫ ОДИНАКОВЫЕ ЭЛ.)
# my_list = [1, "Maksim", True]

# tuple(кортежи) = (НЕИЗМЕНЯЕМЫЙ, ВАЖЕН ПОРЯДОК, ДОПУСТИМЫ ОДИНАКОВЫЕ ЭЛ.),
# У эл. есть индекс.
# my_tuple = ("apple", "banana", "lime")

# set(набор) = (ИЗМЕНЯЕМЫЙ, ПОРЯДОК НЕ ВАЖЕН, НЕ ИМЕЕТ ОДИНАКОВЫХ ЭЛ.)
# Наборы поддерживают Добавление, Удаление новых эл. при этом в наборах
# порядок не важен, пайтон сам решает в какой Последовательности добвлять
# эл., поэтому сравнивая наборы у которых эл. расположены по-разному, но эл.
# одинаковые и их кол-во тоже одинаковое, мы получим результ Истина,
# такие наборы одинаковы в понимании пайтона, но в наборы нельзя добавлять
# одинаковые эл.
# my_set = {'apple', 'banana', 'lime'}

# range(Диапазон) = (НЕИЗМЕНЯЕМЫЙ, ПОРЯДОК ВАЖЕН, НЕ ДОПУСТИМЫ ОДИНАКОВЫЕ ЭЛ.)
# У эл. есть уникальные индексы в диапазоне, не допустимы одинаковые эл.
# потому что создается определенный шаг перебора, по умолчанию этот шаг 1,
# но мы можем изменять его на другое значение, но это в любом случае
# целое число. x = range(3, 20, 2)
# for n in x:
# print(n)

# dict(СЛОВАРИ) =  (ИЗМЕНЯЕМЫЕ, ПОРЯДОК НЕ ВАЖЕН, НЕ ДОПУСТИМЫ ОДИНАКОВЫЕ ЭЛ.)
# их можно изменять, добовляя пару ключ:значени, также как и удалять,
# если сравнивать два словоря с одинаковыми эл. но с разной
# Последовательностью, то такие словари считаются одниковыми.
# Но, при этом в словаре не может быть одинаковых эл., каждый
# эл. уникален. Если мы напишем ниже новое значение для определенного
# ключа, то старое значение будет перезаписано.
# new_dict = {"name": "Maksim", "age": 42}

# str(строка) = (НЕИЗМЕНЯЕМЫЙ, ПОРЯДОК ВАЖЕН, МОГУТ ПРИСУТСТВОВАТЬ ОДИНАКОВЫЕ ЭЛ.)
# Строка неизменяемый объект, но можно создавать новые строки, на основании существующих
# порядок важен, а следовательно каждый символ в строке имеет свой
# уникальный индекс и можно получить первый символ строки используя
# символ 0. По строкам можно выполнять итерацию и например конвертировать
# строку в список и в списке будет определенное кол-во символов.


# Вывод:
# Если нам нужена Последовательность уникальных эл. то лучше
# всего подойдет НАБОР

# Если нам необходимо хранить большое кол-во эл. у которых есть
# свой уникальный индетификатор (ключ), то подходит, конечно же,
# словарь для этих целей

# Если нам необходима просто упорядоченная Последовательность,
# при чем эл. могут быть разных типов, эл. могут повторяться,
# то лучше всего подходит СПИСОК.

# Если нам необходимо сформировать набор данных, в котором
# нельзя будет добавлять или удалять новые эл., то
# лучше подойдет КОРТЕЖ.

# Если необходимо выполнить определенное действие Н-количество
# раз, то для этих целей можно воспользоваться диапазоном.

# Ну, а стороки, чтобы создавать короткие или длинные строки.

# Типы Последовательностей очень хорошо конвертируются друг в друга,
# в случае если нам к примеру нужно будет изменить кортеж, который
# является неизменяемым, в таком случае нам следует конверт. кортеж
# в список, изменить его, и конверт. обратно. Но, этого
# следует избегать, так как это будет означать, что мы подобрали
# неправильно формат данных для значений, если нам все-таки приходится
# изменить кортеж.
# =====================================================
"""
functions:


def my_fn(a, b):
    a = a + 1
    c = a + b
    return c
"""

# У каждой функции есть имя, тело, параметры, также есть
# строка return, что это означает, когда мы вызываем функцию,
# она выполняет определенные действия, в примере выше, функция
# выполняет 3 действия, но кроме этого фурнкция вернет результат,
# и этот результат при желании можно присвоить определенной переменной,
# и использовать его дальше в коде, чтобы явно вернуть определенный
# результат, необходимо использовать определенное слово return .


"""
Встроенные в Пайтон Функции.

print(), type(), id(), len(), sum(), input(), round(),
min(), max(), int(), str(), bool(),

input("Значением здесь всегда является строка,
если нам нужно число, нужно конвертировать эту строку в число")
"""

# Встроенная функция dir()
"""
name = 'Maksim'

print(dir(name))
"""
# С помощью этой функции можно получить список всех отрибутов,
# того или иного объекта. Т.е. у каждого объекта есть атрибуты,
# и названия этих атрибутов, можно вывести в терминал, к примеру,
# путем вызова функции выше.

# В примере выше, функция дир, отобразит все имена отрибутов функции.
# Т.е в параметре этой функции находится строка, а у строк, есть
# отрибуты, которые являются методами.

# К примеру, в этом списке присутствует метод replace(), который
# в свою очередь можно заменить определенную последовательность символов,
# в исходной строке на другую последовательность.


"""
['__add__', '__class__', '__contains__', '__delattr__', '__dir__',
 '__doc__', '__eq__', '__format__', '__ge__',
 '__getattribute__', '__getitem__', '__getnewargs__',
 '__getstate__', '__gt__', '__hash__', '__init__',
 '__init_subclass__', '__iter__', '__le__', '__len__',
 '__lt__', '__mod__', '__mul__', '__ne__', '__new__',
 '__reduce__', '__reduce_ex__', '__repr__', '__rmod__',
 '__rmul__', '__setattr__', '__sizeof__', '__str__',
 '__subclasshook__', 'capitalize', 'casefold', 'center',
 'count', 'encode', 'endswith', 'expandtabs', 'find',
 'format', 'format_map', 'index', 'isalnum', 'isalpha',
 'isascii', 'isdecimal', 'isdigit', 'isidentifier',
 'islower', 'isnumeric', 'isprintable', 'isspace',
 'istitle', 'isupper', 'join', 'ljust', 'lower',
 'lstrip', 'maketrans', 'partition', 'removeprefix',
 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust',
 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines',
 'startswith', 'strip', 'swapcase', 'title', 'translate',
 'upper', 'zfill']"""

# print(dir())

# Ниже идет список методов метода Дир,
"""
['__annotations__', '__builtins__', '__cached__',
 '__doc__', '__file__', '__loader__', '__name__',
 '__package__', '__spec__']
"""

# print(dir(__builtins__))

"""
Если мы передадим метод выше функцие принт, то получим
огромный список отрибутов метода __builtins__.,
т.е. будет выведен список встроеных в пайтон функций,
к примеру set(), round(), print() etc.

Именно таким образом можно вывести весь список встроеных функций в пайтон!
"""

# ===========================================================
#
# Отступы в коде пайтон
# Отступы в Пайтон играют очень важную роль, потому, что
# так пайтон понимает, где начинается тот или иной код.
#

# def print_name_function(name):
#     print(name)
# # тело вышеприведенной функции начинается с отступов в 4 пробела

# print_name_function("Maksim") # Maksim

"""
def sum_nums(a, b):
    sum = a + b
    return sum


first_sum = sum_nums(100, 300)  # 400


# Ключевое слово Ретерт, означает, что функция выполнила определенное
# действие и вернуло определенное значение, и потом мы можем использовать
# этот результат, к примеру для того, чтобы присвоить его переменной.
# либо, чтобы передать его вызове другой функции.
# к прмеру так:

print(first_sum)  # 400

print(sum_nums(2, 66))  # 68

# допустима также передача самой функции в параметры как аргумент,
# при этом результат этой функции будет равняться значению этого параметра
#если не передать функции ретерн, то результат будет None, т.к ничего нам функц. не вернула.

print(sum_nums(sum_nums(50.5, 20), 4000)) #4070.5
"""

# print(print("Maksim")) #Maksim None потому, что не было ключевого слова ретерн.


"""def sum_nums(a, b):
    sum = a + b
    return sum
    print("this will not be executed, because it goes after return")
# как только функция возвращает результат, она прекращает свою работу
# и все остальные строки ниже не выполняются
#
print(sum_nums(44, 88)) #132

"""

# =========================================================


# Выражения

# Результатом выражения является значение
# Выражение всегда возвращает значение,
# Как правило в выражениях всегда находятся один или несколько опереторов
# таких как +, - и т.д. и результат выражения, можно к примеру использовать
# в вызове функции, либо для того, чтобы присвоить такой результат другой переменной.

# Expamle

"""5 + 4 #this is expression
9 #will be result of this expression
"""

# a > b  # expression
# """
# import app.py
# from sys import getsizeof
# import random
# from datetime import date
# from copy import deepcopy
# "Hello" + "World"  # expression
# """
# my_func(10, 5) #expression,
# т.е. результат вызова функции можно использовать в вызовах др. функций
# Потому что вызов функций это выражение.
# Проверить выражение это или нет, можно очень просто путем вызова
# любой функции. Если к примеру мы вызовем Принт и в скобках напишем
# любое выражение, то ошибки не будет, а если мы напишем не выражение
# в круглых скобках, а инструкцию, то получим ошибку.

# Example

"""print(10 + 5)  # 15

print(print(10 + 5)) #15 None - мы выводим результат функции принт
где 15 это результат выражения, то что вывела функци 10 + 5,
т.е. внутренняя функция, которая находится в теле функции, то что
она выполняет, а сама функция принт, внутренняя, вернула нам значение
None, а вот самая первая функция принт, уже и написала, вывела нам
в консоль то что возвращает нам внутренняя функция принт, т.е. None.
Функция Принт всегда возвращает НаН, и это находится в описании
функции Принт. """

# function input = returns str. - this is expression which returns us
# some results type str. Поэтому результат этой функции можно передавать
# какой либо переменной или же присваивать результат этого выражения другой
# функции

# Incorrect expressions:
# print(def my_fn(1, 0))
# print(if True: print())
# Мы не можем использовать инструкцию, там где Пайтон ожидает он нас
# выражение.

# =======================================================

# Инструкции Statements

# Инструкция выполняет действие, либо запускает цикл, либо импортировать
# в другой модуль.

# Examples

# my_name = "Maksim" # Присвоение значения, в Джава скрипт это считается
# выражением, когда в Пайтоне это инструкция.

# if my_name:
#     print(my_name) Это условная инструкция.

# Инструкция выше состоит из ключевого слова if, далее идет выражение
# my_name в данном случае это выражение и в зависемости от того,
# ложно это выражение или же нет, мы выполняем блок кода ниже.
# Это называется условная инструкция.
# Блок условной ниструкции необходимо также отделать от условной части кода
# спомощью отступов.


# import datetime Импортирование модуля. К примеру здесь импортируется
# встроенный в пайтон модуль datetime. И после такого импорта, можно использовать
# все функции которые находятся в этом модуле, непосредственно в вашем файле.
# Импорт это инструкция в Пайтон.

# Есть и другие примеры инструкций, это объявления функций, либо же
# использование ключевого слова ретерн внутри функции.

# Examples:
# Далее можно использовать атрибуты метода datetime.
# Мы можем выводить результат атрибута метода datetime

# import datetime
#
# print(datetime.MAXYEAR)  # 9999
# print(datetime.MINYEAR)  # 1

# если мы передадим эту инструкцию в параметр как аргумент,
# то получим ошибку, но так мы можем проверить, что это инструкция,
# а не выражение.


# print(import datetime) # Error: Expected expression

# =====================================================


# Динамическая типизация
#
# Статическая и динамическая типизация.
#
# Языки программирования делятся на две категори, языки с
# динамической типизацией и статичесткой типизацией.
#
# Пример статической типизации:
#

# String a = 'abc'

# int b = 10

# b = 'xyz' #Error

# т.е. в таких языках, нужно обязательно указывать тип переменной, в пайтоне
# этого делать не нужно, так как он относится к Динамическому типу.


# a = 'abc' # str
# a = 10 #int

# В примере выше, тип сразу же присваевается переменной исходя из значения
# переменной, далее этот тип может меняться, такая структура
# относится к Динамическим, т.е. Пайтон это Динамически Типизированный
# Язык. В Пайтон возможно присвоение новых значений других типов
# одной и тойже переменной.


# В пайтоне можно менять типы переменной, переприсваивая переменной
# значение, на разработчика ложится ответственность в присвоении
# корректного значения. Это очень важно, В примере ниже указана пример
# возможной ошибки.

# def print_name(name):
#     print(name)


# print_name("Maksim")  # Maksim

# print_name = 15

# print_name("Maksim")  # TypeError: 'int' object is not callable


"""
Мы получаем ошибку, потому что раньше это была функция, а теперь
это не функция, но мы пытаемся присвоить ей другой тип данных, поменяв
функцию на число. Т.е мы не можем вызывать объект типа инт.
т.е для пайтон нет проблем присвоить другой тип, но до этого это
была функция, а следовательно меняется функционал переменной.
Нужно быть внимательным, чтобы не допустить подобных ошибок.

Правила Работы с Переменной.

1. Всегда выбирать осмысленные названия.
2. В названиях переменных использовать имя существительное, например
name, comments, new_photos. Т.е имена переменных
должны отвечать на вопрос ЧТО СОДЕРЖИТ ЭТА ПЕРЕМЕННАЯ.
3. Названия функций и методов начинать с глагола, например
Т.е название должно отвечать на вопрос ЧТО ДЕЛАЕТ ФУНКЦИЯ,
что возвращает, что выполняет.
get_data, create_request, merge_name etc. из названия должно быть
понятно, что функция выполняет.

"""

# ===================================================

# Типы и структуры данных.

# В пайтон отсутсвуют примитивные типы данных.
# потому что в пайтон все сущности, это объекты.
# Даже если мы создаем число, то в памяти комп. создается
# объект типа ИНТ. и этот объект является экземпляром класса инт.
# Если мы создали объект с цифрой 10, то создается один объект в памяти,
# если мы создали другое число к примеру 15, и присвоили его другой
# либо даже той же самой переменной, то создается новый объект в памяти.
# этот объект также является экземпляром класса инт, но он не зависит
# от объекта который содержит число 10. Это два разных объекта.

# В Пайтон существуют Изменяемые и Неизменяемые объекты. Т.е объект
# у которого тип значения инт. - является неизменяемым. создается другой
# объект, с другим значением, но старый не изменяется.

# А, вот к примеру список, является изменяемым объектом. Можно добавлять
# или же удалять из него эл., при этом сам объект остается в памяти
# и мы изменяем этот объект.

# Изменямемые объеты это Mutable objects. часто говорят, мутировать
# объект без создания нового объекта.
"""
name = "Maksim"
lastname = "Maksim"
print(name == lastname) #True

print(id(name) == id(lastname))
"""
"""Неизменяемые объекты это Immutable objects.

Типы неизменяемых объектов:

str - string (строка) - str
bool - boolean (логический) - bool
int - integer (целое число) - int
float(число с десятичной точкой)
tuple(кортеж)
None(ничто) - NoneType
range(диапазоны)


Изменяемые Объекты Mutable.

list()
dict()
set()
user-defined classes(Экземпляры классов, которые мы сами создаем)
Т.е мы можем мутировать объеты выше, при этом новые объеты не будут
создаваться.

"""


# ======================================================

# Все переменные содержат собственные уникальные ссылки на объект,
# следовательно у них присутстуют адреса по которым их можно найти.
"""
my_country = "USA"
print(id(my_country))  # 136602039944880

other_country = "Turkmenistan"
print(id(other_country)) #138440542848496
"""

# Но, Переменные могут ссылаться на один и тот же объект

# Например:

# my_name, new_name, other_name = это возможно, если скопировать
# одну переменную в другую.
"""
my_name = "Maksim"

other_name = my_name #id 137732415374960

new_name = other_name #id 137732415374960

print(new_name)  # Maksim id 137732415374960

print(id(my_name))
"""

# Таким образом, можно ссылаться на один и тот же объект в памяти
# имея разные переменные. При этом новый объект не создается.
#

# ==================================================

# Строки...............................


# name = input("Enter your name: ")

# print(name)

# print(name.capitalize())

# print(dir(name))


# def printMyName(name):
#     return name


# print(printMyName("Maksim"))


"""my_var = 10
print(id(my_var))
my_var = "Maksim"
print(id(my_var))
my_var = True

print(my_var)"""

"""
floatNum = 11.3
print(floatNum)

converted_float_num = int(floatNum)

print(float(1))

print(round(17.4))

"""
# Комплексное число
"""complex_a = 3 + 5j
complex_b = 4 + 7j

sum = complex_a + complex_b

print(sum)  # (7+12j)

print(type(sum))  # class complex

complex_c = 50 - 20j
complex_d = 40 - 5j
sum = complex_c - complex_d

print(sum)

complex_e = 10 + 7j
complex_f = 3 + 3j

sum = complex_e * complex_f

print(sum)  # (10 + 7j) (3 + 3j) = 30 + 30j + 21j + 21j^ = 9 + 51j
"""


# Boolean
"""print(bool(10))  # True
print(bool("abc"))  # True
print(bool([]))  # False
print(bool([1, 2]))  # True
print(bool(None))  # False
print("===============")
print(100 > 10)  # True
print("Long string" < "sort")  # False так происходит,
потому что каждая буква имеет свой специальный юникод.

print([] == [])  # True

print([1, 2, 3] == [1, 2, 3]) #True
print({"a": 3} == {"a": 3}) #True
"""
# ======================================

# Python не выполняет неявную конвертацию типов значений

# Встроенные функции для явной конвертации типов

# str(), float(), tuple(), int(), list(), set()
"""
# Операция с значениями разных типов
"10" + 5  # TypeError: can only concatenate str (not "int") to str
"""
"""
5 + "10" #TypeError: unsupported operand type(s) for +: "int" and "str"
"""
"""
int_num = 5
float_num = 4.5
print(int_num + float_num) #9.5 No Error


print(int_num.__add__(float_num))
этот метод не смог вернуть нам результам, следовательно используется
метод указанный ниже.

конвертация выше возможна,
потому, что вызывается магический метод и в вызове этого
метода пайтон передает float_num, этот метод класса инт, вернет
строку NotImplemented, что означает, что операция добавления
нецелого числа и интеджер не реализовано на уровне класса интеджер.

Здесь, пайтон не выполнил конвертацию чисел, он просто вызвал
один из методов класса. Конвертация не была реализована.

print(float_num__radd__(int_num)) именно это метод возвращает нам 9.5

Но, если пайтон видит, что метод __add__ не может быть выполнен,
он вызывает другой метод __radd__(добавление справа) для другого операнда, в данном случае
операнда float_num, а вот на уровне float возможна реализация добавления
интеджер к флоат.
Магические методы так называются, потому что выполняются автоматически
при использовании различных операторов
"""
"""
bool_val = True
int_val = 7


print(bool_val + int_val)  # 8, because True is equal 1


print(int_val + bool_val)

int_num = 5
float_num = 4.5
print(float_num + int_num)
"""
"""
int_num = 50
float_num = 7.5
str_val = "abc"

print(int_num.__mul__(float_num))  # NotImplemented
print(int_num.__rmul__(float_num))  # NotImplemented

print(float_num.__radd__(int_num))  # 57.5
print(float_num.__mul__(int_num))  # 375.0

print(int_num * str_val)  # abcabcabcabcabcabca

print(str_val.__mul__(int_num))  # abcabcabcabcabcabca

print(int_num.__rmul__(str_val))  # NotImplemented
print(int_num.__mul__(str_val))  # NotImplemented
print(float_num.__mul__(str_val))  # NotImplemented
print(str_val.__rmul__(float_num)) #TypeError: 'float' object cannot
be interpreted as an integer
"""


# =====================================================
# Магические методы - внутренние методы классов и они обычно не вызываются явно
"""
Функция dir() позволяет получить доступ к списку функций,
того или иного объекта.

print(dir(bool)) Выведится лист со всеми атрибутами и методами bool
но там не все является методами, к примеру __doc__ это атрибут,
который содержит строку.
__add__()
__eq__()
__and__()
__str__()
__neq__()
__or__()
"""

# print(bool.__doc__)
"""
bool(x) -> bool

Returns True when the argument x is true,
False otherwise.
The builtins True and False are the only two
instances of the class bool.
The class bool is a subclass of the class int,
 and cannot be subclassed.
"""
"""
my_list = []

print(help(my_list.__eq__))  #__eq__(value, /) unbound
    #builtins.list method
    #Return self==value.
    #None
"""

# List Списки=====================================

# Списки это упорядоченная последовательность элементов
# У каждого элемента списка свой порядковый номер
"""
my_fruits = ["apple", "banana", "lime"]

prostw_id = [151, 32, 453, 34,]

user_inputs = [True, "hi", 10.5]

# Длинна списка

empty_list = []
print(len(empty_list))  # 0

print(len(my_fruits))  # 3

print(prostw_id[1])  # 32
print(prostw_id[-1])  # 34

prostw_id[0] = 555
print(prostw_id)  # [555, 32, 453, 34]

del prostw_id[0]

print(prostw_id)  # [32, 453, 34]


user = [
    {
        "user_id": 134,
        "user_name": "Alice"
    },
    {
        "user_id": 831,
        "user_name": "Bob"
    }
]

print(len(user))  # 2

print(user[1]["user_name"])  # Bob

my_fruit = "apple"
other_fruit = "banana"
new_fruit = "lime"

all_fruits = [my_fruit, other_fruit, new_fruit]

print(all_fruits)  # ['apple', 'banana', 'lime']

prostw_ids = [1534, 343, 34, 3]
print(prostw_ids[10])  # IndexError: list index out of range
"""
# Methods for list
# append, pop, remove, insert, sort, index, clear, copy, extend,
# reverse, count
# Методы списков объекты наследуют от класса LIST
"""
greeting = []

greeting.append("Hello")
greeting.append("Maksim")

print(greeting)  # ['Hello', 'Maksim']
# Добавляется элемен в конец списка.


# Method pop() Удаляет и возвращает последний элемент из списка
# Эти методы изменяют существующий список

removed_el = greeting.pop()
print(removed_el)  # Maksim

print(greeting)  # Hello

print(greeting.pop(0))  # Hello
print(greeting)  # []
"""


# Method SORT
"""
post_ids = [234, 15, 723, 134]

post_ids.sort()


print(post_ids)  # [15, 134, 234, 723]

post_ids.sort(reverse=True)
print(post_ids) #[723, 234, 134, 15]
"""
"""
# Конвертация в СПИСОК

greeting = "Hello from Python"
greeting_letters = list(greeting)

print(greeting_letters)  # ['H', 'e', 'l', 'l', 'o',
# ' ', 'f', 'r', 'o', 'm', ' ', 'P', 'y', 't', 'h', 'o', 'n']

my_dict = {"a": 10, "b": True}
my_dict_keys = list(my_dict)

print(my_dict_keys)  # ['a', 'b'] Значения при такой конверт. теряются
# остаются только коючи

# Арифметические операции в Списках

ratings = [2.5, 5.0, 4.3, 3.7]

print(min(ratings))  # 2.5
print(max(ratings))  # 5.0
print(sum(ratings))  # 15.5

print(sum(ratings)/len(ratings))  # 3.875

# Объединение списка

my_ratings = [2.5, 5.0]

other_ratings = [3.7, 4.5, 4.9]

all_ratings = my_ratings + other_ratings

print(all_ratings)  # [2.5, 5.0, 3.7, 4.5, 4.9]

# При использовании оператора + вызывается метод списков __add__
# поэтому списки так легко объединяются...

first_two_ratings = ratings[:2]
print(first_two_ratings)  # [2.5, 5.0] Забрал первые 2 элемента

middle_ratings = ratings[1:-1]
print(middle_ratings)  # [5.0, 4.3] Забрал середину

last_two_rationgs = ratings[-2:]
print(last_two_rationgs) #[4.3, 3.7] Забрал последние два эл.

# При этом оригинальный список не изменяется...

"""

# Копирование списка, копирование по ссылке

"""
my_cars = ["BMW", "Mercedes"]

copied_cars = my_cars

copied_cars.append("Audi")

print(copied_cars)  # ['BMW', 'Mercedes', 'Audi']

print(my_cars)  # ['BMW', 'Mercedes', 'Audi']

print(id(my_cars) == id(copied_cars))  # True
"""

# Копирование не по ссылке, что позволяет нам не изменять старый список


# 1 Вариант, используя метод slice()
"""
my_cars = ["BMW", "Mercedes"]

copied_cars = my_cars[:]

copied_cars.append("Audi")

print(copied_cars)  # ['BMW', 'Mercedes', 'Audi']

print(my_cars)  # ['BMW', 'Mercedes']

print(id(my_cars) == id(copied_cars))  # False
"""

# 2ой вариант, используем метод copy()

"""
my_cars = ["BMW", "Mercedes"]

copied_cars = my_cars.copy()

copied_cars.append("Audi")

print(copied_cars)  # ['BMW', 'Mercedes', 'Audi']

print(my_cars)  # ['BMW', 'Mercedes']

print(id(my_cars) == id(copied_cars)) #False"""

# 3ий вариант, создание списка используя фуркцию list()
"""
my_cars = ["BMW", "Mercedes"]

copied_cars = list(my_cars)

copied_cars.append("Audi")

print(copied_cars)  # ['BMW', 'Mercedes', 'Audi']

print(my_cars)  # ['BMW', 'Mercedes']

print(id(my_cars) == id(copied_cars))  # False

"""

# Вывод: Списки в пайтон изменяемые, следует использовать методы,
# если не хотим, чтобы оригинальный список изменялся...

# Practise
"""
my_nums = [10, 50, 0, 5, 100]

print(type(my_nums))  # class 'list'

#['__add__', '__class__', ect... список имен всех отрибутов класса
print(dir(my_nums))
'''
append', 'clear', 'copy', 'count', 'extend',
'index', 'insert', 'pop',
'remove', 'reverse', 'sort'] эти методы в том числе'''
"""

# my_nums = [10, 50, 0, 5, 5, 100]
"""
res = my_nums.count(5)
print(res)  # 2, т.е. элемент 5 в списке встречается дважды

my_nums.append(25)

print(my_nums)  # [10, 50, 0, 5, 5, 100, 25]
"""
"""
# Этот метод встваляет объект перед определенным индексом
my_nums.insert(1, 333)
# [10, 333, 50, 0, 5, 5, 100], но этот результат нельзя присвоить другой переменной
print(my_nums)

my_nums.clear()
print(my_nums)  # [] Empty list
"""

# Рассширяет список добовляя элемент в другой последовательности
"""
my_nums = [10, 50, 0, 5, 5, 100]

my_nums.extend("abc")
print(my_nums)  # [10, 50, 0, 5, 5, 100, 'a', 'b', 'c'], добавляются
# элементы в конец списка, также этот метод можно использовать, чтобы
# расширить другой список, при этом один из списков будет изменен
other_nums = my_nums
print(id(my_nums))  # 124296466841344
print(id(other_nums))  # 124296466841344
print(id(other_nums.copy())) #123730857641216
"""

# Задачи
"""
# 1. Создайте список с 5 элементами разных типов
new_list = [1, True, None, "Maksim", []]
print(new_list)
# 2. Удалите третий элемент
del new_list[2]
new_list.pop(2) также можно использовать
print(new_list)
# 3.Выведите в терминал длину списка
print(len(new_list))
# 4.Поменяйте порядок следования элементов в списке
new_list.reverse()
print(new_list)
# 5.Создайте еще один список с двумя элементами
two_more_el = ["Hello", "Added"]
# 6.Расширьте первый список элементами второго списка

new_list.extend(two_more_el)
# 7.Выведите в терминал расширенный список из 6 элементов

print(new_list)
print(f" The length of new_list is:{len(new_list)} elements")


"""
# Задача №2
"""
# 1. Создайте два списка
first_list = [11, True, "Maksim"]
second_list = [[1, 3], {"a": 10}]

# 2. Объедините два списка, используя опертор +
joined_lists = first_list + second_list
print(joined_lists)
# 3. Определите, какоей магический метод списков
# вызывается при использовании оператора +


# 4. Выполнение слияние списков, используя этот магический метод
added_method = first_list.__add__(second_list)
reversed_list = second_list.__add__(first_list)

# 5. Результат выведите в терминал
print(added_method)
print(reversed_list)
"""


# Словари DICT -  Словарь это набор эл. ключ:значение
# В словаре ключи являются уникальными, если вы используете ключ ниже
# то значение этого ключа перезапишется...
# порядок эл. в словаре не имеет значение, поиск происходить по ключам

"""
my_motorbike = {
    "brand": "Ducati",
    "price": 25000,
    "engine_vol": 1.2,
}

other_motorbike = {
    "brand": "Ducati",
    "engine_vol": 1.2,
    "price": 25000,
}

# True технически для пайтона это одинаковые объекты
print(id(my_motorbike) == id(other_motorbike))  # False
print(my_motorbike == other_motorbike)  # True

# но, так как имена словаря разные, словари ссылаются на разные имена в памяти
# т.е. id у этих словарей(объектов) - разные
# но, если число элементов разнится в словарях, то такие словари будут разные
# при сравнении словарей используется магический метод, который сравнивает
# только значения ключей элементов, при этом не учитывает их порядок
# т.е не нужно производить итерацию, чтобы узнать одинаковые ли словари или же нет

"""

# Получение значения в словарях
"""
Доступ к ключам через точку в пайтоне не возможен
, так как через точку в пайтоне осуществляется доступ к атрибутом
объекта, а ключи словаря не являются отрибутом объекта, следует
использовать только квадрадные скобки.
проверить какие атрибуты присутсвуют у объекта можно
через функцию dir()"""
"""
color = "Blue"
my_motorbike = {
    "brand": "Ducati",
    "price": 25000,
    "engine_vol": 1.2,
    color: color,
}

print(my_motorbike["brand"])  # Ducati
print(my_motorbike[color])  # Blue
my_motorbike["price"] = 7000
print(my_motorbike) #price will be changed for 7000
"""


# Добавление элементов в словарь
"""
my_motorbike = {
    "brand": "Ducati",
    "price": 25000,
    "engine_vol": 1.2,
}

my_motorbike["is_new"] = True

print(my_motorbike) #Добавиться новый элемент "is_new": True

#если такой ключ уже существует, то его значение будет перезаписано

"""

# Удаление элементов
"""
my_motorbike = {
    "brand": "Ducati",
    "price": 25000,
    "engine_vol": 1.2,
}

del my_motorbike["price"]
print(my_motorbike)
"""


# Словари - Доступ к значению эл. с помощью переменной

"""
my_motorbike = {
    "brand": "Ducati",
    "price": 25000,
    "engine_vol": 1.2,
}

key_name = "brand"
second_key = "price"

my_motorbike[key_name] = "BMW"
my_motorbike[second_key] = 300

print(my_motorbike)
"""

# Вложенные словари
"""
my_motorbike = {
    "brand": "Ducati",
    "price": 25000,
    "engine_vol": 1.2,
    "price_info": {
        "price": 244,
        "is_available": True,
    }
}

print(my_motorbike["price_info"]["is_available"]) #True
"""

# Словари = Использование словарей и добавление результа фунций в значение
# ключей
"""
first_num = 3
second_num = 4


def sum_nums():
    return first_num * second_num


my_motorbike = {
    "first_digit": first_num,
    "second_digit": second_num,
    "brand": "Ducati",
    "price": (f" total price is {sum_nums()}"),
    "engine_vol": 1.2,
}

print(my_motorbike)


Вывод:

{'first_digit': 3, 'second_digit':
4, 'brand': 'Ducati',
'price': ' total price is 12',
'engine_vol': 1.2}

#========================
"""

# Длина словаря
"""
first_num = 3
second_num = 4


def sum_nums():
    return first_num * second_num


my_motorbike = {
    "first_digit": first_num,
    "second_digit": second_num,
    "brand": "Ducati",
    "price": (f" total price is {sum_nums()}"),
    "engine_vol": 1.2,
}

print(len(my_motorbike)) #5
"""

# Словари = Несуществующие ключи (очень важный момент)
"""

my_motorbike = {
    "brand": "Ducati",
    "price": 34343,
    "color": "Blue",
}
print(my_motorbike.get("model"))  # None
print(my_motorbike.get("brand"))  # Ducati

# print(my_motorbike["model"]) #KeyError: 'model'


# если пытаться обратиться к ключу, которого нет, то код выдаст ошибку
# и остановится. Чтобы избежать этого, можно проверить существует ли
# такой элемент или же нет используя атрибут get(),
# если элемент существует, он вернет значение этого элемента,
# если такого ключа нет, то вернет None
# следовательно метод get() предпочтительнее использовать, если
# нам нужен доступ к значениям ключей

print(my_motorbike.get("airplane", 0))  # 0
# т.е. этот метод дает нам возможность использовать значение
# поумолчанию, если такого ключа не существует.
"""

# Словари - Резюме - Атрибут __doc__
"""
my_dict = {}
print(my_dict.__doc__)

#Это функция конструктор, для создания новых
# экземпляров класса dict
"""

# Practice
"""
my_disk = {}
print(id(my_disk))  # 124919792645440
print(type(my_disk))  # <class 'dict'>
my_disk["brand"] = "Samsung"
my_disk["price"] = 32342

print(my_disk)  # {'brand': 'Samsung', 'price': 32342}

print(id(my_disk))  # id не меняется при изменении

print(my_disk.items())  # dict_items([('brand', 'Samsung'), ('price', 32342)])
# результат вывода выше, есть список с двумя картежами

print(type(my_disk.items()))  # <class 'dict_items'>

print(my_disk.keys())  # dict_keys(['brand', 'price'])

print(list(my_disk.keys()))  # ['brand', 'price'] converted to the list

#('price', 32342) вернул кортеж с последним элементом в списке
print(my_disk.popitem())
# но метод попайтем, который мы использовали выше, лучше не стоит.
# т.к. списки неупорядочены, а этот метод удаляет последний элемент
# и следовательно, мы не можем прогнозировать, какой элемент будет удален.
# лучше использовать метод del

print(my_disk) #{'brand': 'Samsung'} вернул оставшийся список
"""

# Method copy the same for the dick as in the list, creats a new copy of the dict.
"""
my_disk = {
    "type": "hard_disk",
    "size": 256,
}

new_disk = my_disk.copy()

new_disk["type"] = "ssd"

print(my_disk)
print(len(my_disk))
print(new_disk)
print(len(new_disk))
"""
"""
my_list = [0, True, "abc"]

my_dict = dict(my_list)
# function dict() это функция конструктор по созданию экземпляров словаря
# TypeError: cannot convert dictionary update sequence element #0 to a sequence
print(my_dict)
"""

"""
my_list = [["first", 0], ["second", True]]

my_dict = dict(my_list)

print(my_dict) #{'first': 0, 'second': True}

# т.е пайтон выполнил конвертацию из списка в словарь
#таким образом можно создавать словари из списков
"""

# Задача
"""
1. Создайте пустой словарь

2. Трижды попросите пользователя сначала
внести название ключа, а потом ввести
значение для этого ключа. Всего должно быть
6 запросов на ввод текста.

3. во время получения данных от пользователя
добавьте в словарь ключи с значениеями
согласно тому, что ввел пользователь.

4. Выведите результирующий словарь в терминал

5. Добавить и удалить несколько ключей

new_list = {}

key_name = input("Insert the key: ")
new_list[key_name] = input("Insert the value: ")

key_name2 = input("Insert the key: ")
new_list[key_name2] = input("Insert the value: ")

key_name3 = input("Insert the key: ")
new_list[key_name3] = input("Insert the value: ")

print(new_list)

del new_list[key_name2]

print(new_list)
"""

# Кортежи - это упорядоченная последовательность элементов

# Кортежи очень похожи на списки, но их ИЗМЕНЯТЬ НЕЛЬЗЯ

# В списки можно добавлять или же удалять элементы,
# а в кортежах нельзя. Каким он создается, таким и остается.
# Объект типа ТАПЛ - не изменяемый в пайтоне.
# Также как и строка или же целое число.

# В картежах могут быть эл. как однотипные так и разнотипные.

# Как правило, кортежи небольшие и содержат 2, 3, 4 эл.
# где элементы помещаются между парой круглых скобок

"""
my_fruits = ("apple", "banana", "lime")

user_inputs = (True, "hi", 10.5)

# Порядок следования эл. в кортеже важен.
# Ниже приведенные кортежи - РАЗНЫЕ КОРТЕЖИ
my_fruits = ("apple", "banana", "lime")
other_fruits = ("banana", "apple", "lime")

print(my_fruits == other_fruits)  # False

print(len(my_fruits))  # 3

# Доступ к эл. через идексы как и в листе
print(my_fruits[0])  # apple
print(my_fruits[-1])  # lime

my_fruits[0] = "Hello"
print(my_fruits)  # TypeError: 'tuple' object
# does not support item assignment НЕЛЬЗЯ МЕНЯТЬ
"""

# Доступ к спискам внтури кортежей
# списки внутри словарей можно менять.
"""
users = (
    {
        "user_id": 134,
        "user_name": "Alice",
    },
    {
        "user_id": 831,
        "user_name": "Bob",
    }
)

print(users[1]["user_id"]) #831

users[1]["user_id"] = 100

print(users[1]["user_id"]) #100
"""

# Формирование элементов при помощи переменных извне
"""
my_fruits = "apple"
other_fruit = "banana"
new_fruit = "lime"

all_fruits = (my_fruits, other_fruit, new_fruit)

print(all_fruits) #('apple', 'banana', 'lime')
"""

# Несуществующие элемента
"""
posts_ids = (151, 245, 343, 3423, 333)

print(posts_ids[10]) #IndexError: tuple index out of range

"""
"""
posts_ids = (151, 245, 343, 3423, 333)

print(len(posts_ids)-1 == 4) #True
"""
# Вариант выше дает нам возможность узнать индекс последнего эл.
# и в случае необходимости обращения к последнему элем.
# мы будем точно знать сколько эл. в кортеже.

# Слияние двух кортежей
# При использовании оператора + вызыввается метод кортежей __add__
# При этом оригинальные кортежи остаются без изменений, так как
# кортежи изменять нельзя
"""
internal_ids = (151, 234)
external_ids = (255, 877)

joined_ids = internal_ids + external_ids

print(joined_ids)  # (151, 234, 255, 877)

print(internal_ids) #(151, 234)

"""

# Methods of tuples Методы кортежей.

# У кортежей есть только два метода COUNT AND INDEX

# При помощи коунт можно посчитать количество эл. в кортеже
# Ну а при индекс можно узнать индекс определенного элемента
# методов добавления и удаления эл. нет, т.к. он не изменяется.

# Методы  Кортежей наследуются от класса tuple потому, что именно из
# этого класса и создаются все экземпляры этого объекта.

"""
posts_ids = (151, 257, 784, 257)

print(posts_ids.count(257))  # 2

print(posts_ids.count(151))  # 1

# Если эл. встречается несоклько раз, то возвращается индекс первого эл.

print(posts_ids.index(257))  # 1

print(posts_ids.index(784))  # 2
"""

# Если нам нужно изменить кортеж, мы можем конвертировать его в список
# а, после конвертировать обратно в кортеж

"""
posts_ids = (151, 245)

posts_ids_list = list(posts_ids)
posts_ids_list.append(351)

print(posts_ids_list)  # [151, 245, 351]

posts_ids_tuple = tuple(posts_ids_list)

print(posts_ids_tuple)  # (151, 245, 351)
"""

# чтобы найти индексы других похожих эл. в кортеже можно использовать
# подобный подход
"""
my_nums = (10, 5, 100, 0, 5, 5)

index_one = my_nums.index(5)
index_two = my_nums.index(5, index_one + 1)
print(index_one)  # 1
print(index_two)  # 4

index_three = my_nums.index(5, index_two + 1)
print(index_three)  # 5
"""
"""
my_nums = (10, 5, 100, 0, 5, 5)

new_list = list(my_nums)

new_list.append(7)

new_taple = tuple(new_list)

print(f"this is old tuple: {my_nums}")
# this is old taple: (10, 5, 100, 0, 5, 5)

print(f"this is modified tuple to the list: {new_list} ")
# this is modified tuple to the list: [10, 5, 100, 0, 5, 5, 7]

print(f"this is modified tuple: {new_taple}")
# his is modified tuple: (10, 5, 100, 0, 5, 5, 7)

# также можно этой же переменой присвоить результат кортежа
my_nums = tuple(new_list)
print(my_nums)  # (10, 5, 100, 0, 5, 5, 7)
"""

# Приведение строки к кортежу
"""
my_tuple = tuple("abcd")
print(my_tuple)  # ('a', 'b', 'c', 'd')

# Приведения эл. списка в кортеж, при этой конвертации
# мы получаем кортеж из ключей

my_list_tuple = tuple({"name": "Maksim", "age": 43})

print(my_list_tuple) #('name', 'age')
"""

# TAKS
"""
my_tuple = (123, "Maksim", True)

my_tuple_list = tuple({"ocupation": "IT", "living place": "Minnesota"})

joined_tuples = my_tuple + my_tuple_list

print(joined_tuples) #(123, 'Maksim', True, 'ocupation', 'living place')
"""


# TYPE: SET - НАБОРЫ
"""
Данный тип является очень мощным инструментом в пайтон
он легко позволяет выполнять различные действия с разными типа данных
Например можно легко найти пересечения двух наборов элементов
либо же можно объеденить два набора элементов, при чем в результате
мы получим только уникальные элементы.

НАБОР - ЭТО НЕУПОРЯДОЧЕННАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ ЭЛЕМЕНТОВ,
т.е порядок элементов в наборах роли не играет, в наборах
у эл. нет индексов, набор содержит только уникальные элементы,
и если мы добавляем эл. который уже есть, то такой эл. добавлен
не будет.

Но, изменять наборы можно, и можно добавлять эл. в набор и удалять их

В наборах обычно сохраняют однотипные объекты, например набор строк,
либо набор целых чисел, либо набор чисел с плавающей точкой.
Обычно добавляются однотипные данные в набор.

Отличие наборов от словарей - у наборов только присутсвует эл.,
а у словарей пара = ключ: значение.

В наборе могут быть объекты разых типов, но не желательно так делать.

Т.е. у набора будут присутствовать собственные методы, отличные от списка


"""
"""
my_fruits = {"apple", "banana", "lime"}
print(my_fruits)  # {'banana', 'apple', 'lime'}

posts_ids = {151, 245, 762}
print(type(posts_ids))  # <class 'set'>

user_inputs = {True, "hi", 10.5}
print(user_inputs)  # {True, 'hi', 10.5}, но так делать не следует
"""
"""
posts_ids = {151, 245, 762, 151, 245}

print(posts_ids)  # {762, 245, 151}

print(type(posts_ids))  # <class 'set'>

print(len(posts_ids))  # 3
"""

# Т.е. Наборы возвращают только уникальные эл. повторы не выводятся
"""Что нам дают Наборы - возможность найти уникальные значения среди
болшой последовательности неуникальных последовательностей,
Допустим у нас содержится список ай ди комментариев,
и наша задача найти только уникальные значения, поэтому
список к примеру можно конвертировать в набор и обратно,
в таком случае уникальный эл. можно найти быстрее.
При этом неуникальные значения будут удалены и останутся только уникальные.
И далее мы можем провести итерацию по набору и выполнить определенные
действия уже с уникальными значениями(с каждым из комментариев).
"""
"""
my_fruits = {"apple", "banana", "lime"}

other_fruits = {"banana", "apple", "lime"}

print(my_fruits == other_fruits) #True
"""
# Наборы вышеприведенные одинаковые, потому что у них совпадают
# количество эл. и сами эл., при этом последовательность
# неважна.
"""
posts_ids = {123, 343, 3543, 5434, 43432}
print(posts_ids[2]) #TypeError: 'set' object is not subscriptable
"""
# Потому что индексов у наборов нет.
# Ошибку выше мы будем получать всегда если у объектов
# нет магического метода __getitem__
# к примеру если поменять набор на список, то используя метод
# гетаймс и мы можем обратиться к списку и через индекс найти
# нужный нам эл.

"""
posts_ids = {123, 343, 3543, 5434, 43432}

print()

posts_ids = [123, 343, 3543, 5434, 43432]

sec_index = posts_ids.__getitem__(2)
print(posts_ids[0]) #123
print(sec_index)  # 3543
"""

# Также эта функция не доступна для целых чисел, но для дробных она доступна
"""
a = 10, 4
print(a[0])  # 10

a = 20
print(a[0])  # TypeError: 'int' object is not subscriptable
"""

# Изменяемые объекты в наборах
# В наборы нельзя добавлять, изменяемые объекты, таки как list, dict, set
"""
lists_set = {[1, 3], [20, 5]}
print(lists_set)  # TypeError: unhashable type: 'list'
"""


"""В наборах не может быть одинаковых эл. для того, чтобы проверять
уникальность эл. в наборах для каждого эл. генерируется хеш и
этот хеш для каждого эл. не изменяется пока этот эл. есть в наборе.
Предположим, что мы хотим изменить список и добавить в него новый эл.
в таком случае необходимо будет изменить хеш для этого списка, но если
изменится хеш, то необходимо будет пересмотреть все остальные эл.
в наборе, возможно какие то эл. будут одинаковы и необходимо будет удалить дублекат.
но набор существует не для этого, он существует для того, чтобы
содержать уникальные эл. и не удалять существующие, поэтому в наборах
не могут присутствовать изменяемые объекты. """

# Улдалять эл. с помощью del нельзя, но для удаления эл. в наборах
# существуют другие методы
"""
photo_dimensions = {"1920x1080", "800x600"}
print(len(photo_dimensions))  # 2

# TypeError: 'set' object doesn't support item deletion
del photo_dimensions[1]
"""
"""
my_set = {10, 10, 5, 15, 15}

print(my_set) #{10, 5, 15}
print(len(my_set)) # 3

del my_set[0] #TypeError: 'set' object doesn't support item deletion

"""
"""
my_set = {[10, 10], 5, 15, 15}

print(my_set)  # TypeError: unhashable type: 'list'

ошибка выше происходит из-за того, что мы пытаемся поместить
изменяемый объект в неизменяемый и потому, что хеш для него,
нужно будет каждый раз изменять, что не допустимо в наборах.
В наборах хеши для эл. не изменны.
"""
"""
my_set = {(10, 10), 5, 15, 15}

print(my_set) #{(10, 10), 5, 15}
"""
# кортежи внутри наборов возможны, так как они также являются
# неизменяемыми объектами.


# Empty SET, Так создается пустой набор
"""
my_set = set()

print(my_set) #set()
print(type(my_set)) #<class 'set'>
"""

"""Теперь в этот набор, можно добавлять и удалять эл.
Это функция конструктор с помощью которой создаются экземпляры
класса сет.

Еще раз, в наборах не могут присутствовать изменяемые объекты - элементы"""

# Set Methods

"""
Some of the Set Methods

add, union, remove, difference, intersection, discard,
clear, copy, update, issubset, issuperset, pop

получается, что методы наборов наследуются от класса СЕТ,
потому что каждый набор является экземпляром класса сет"""

# Method ADD

"""
photo_sizes = {"1920x1080", "800x600"}

photo_sizes.add('1024x768')

print(photo_sizes) #{'1024x768', '800x600', '1920x1080'}
"""

# При этом при добавлении такого эл. пайтон обязательно проверит,
# есть ли такой эл. в этом наборе. А выполняется сравнение, путем
# генерации хешей.

# Method UNION

# Это тот случай, когда мы закрашиваем оба набора, включая пересечения
# Но, если какие то эл. включаются в обоих множествах, то они
# останутся только в единичном экземпляре.
"""
photo_sizes = {"1920x1080", "800x600"}

other_sizes = {'1024x768', '800x600'}

all_sizes = photo_sizes.union(other_sizes)

print(all_sizes) #{'800x600', '1920x1080', '1024x768'}
"""
# Кроме этого можно использовать вместо метода union операто |,
# он также выполнит также объединение двух наборов


# Method INTERSECTION

"""
photo_sizes = {"1920x1080", "800x600"}

other_sizes = {'1024x768', '800x600'}

# common_sizes = photo_sizes.intersection(other_sizes)
common_sizes = photo_sizes & (other_sizes)

print(common_sizes)  # {'800x600'}
"""
# С помощью этого метода можно находить пересечения двух наборов,
# и в данном случае мы получаем набор только из одного эл.
# потому, что только этот эл. является общим в обоих наборах.
# Также вместо методода INTERSECTION можно использовать оператор & .
# При использовании методов выше, оригинальные наборы не изменяются.
# а их методы возвращают новый набор, поэтому этот результам можно
# присвоить другой переменной

# Method ISSUBSET

"""
nums = {10, 5, 35}

other_nums = {20, 5, 12, 10, 35}

res = nums.issubset(other_nums)

print(res) #True
"""

# Т.е. есть окружность (множество) В, внутри которой находится меньшая окружность А,
# так вот все эл. А, принадлежат окружности (множества) В, но в множестве В, больше
# эл. нежели в множестве А, получается множество А, является подмножеством множества В.
# и как раз это проверить можно при помощи метода ISSUBSET,
# также можно проверить находится ли А внутри В, т.е. является ли В,
# супермножеством, множества А, т.е. если в В больше эл. чем в множестве А,
# то В считается супермножеством множества А, и вот этот метод проверяет
# включен ли один набор в другой.

# В примере выше, больший набор включает в себя все эл. меньшего набора
# Поэтому мы и получаем Труе, потому что одно множество является подмножеством
# второго множества

# Method issuperset

# При этом методе, можно проверить включен ли меньший набор в больший

# Ключивые моменты в множествах, это то, что множества содержат только
# уникальные эл. и то что эл. в множествах не имеют четкой последовательности


# Practice of the Set's Methods
"""
my_set = {"abc", 'd', 'f', 'y'}
other_set = {'a', 'f', 'd'}

print(my_set.intersection(other_set))  # {'d', 'f'}
print(other_set.intersection(my_set))  # {'d', 'f'}
print(my_set.intersection('abc'))  # set()

# в методе ниже, происходит итерация по символам, поэтому
# этот метод находит совпадения на "d"

print(my_set.intersection('abcd'))  # {'d'}
print(my_set.intersection(['a', 'b', 'c', 'd']))  # {'d'}
print(my_set.intersection(('a', 'b', 'c', 'd')))  # {'d'}

print(my_set.union(other_set))  # {'a', 'y', 'abc', 'f', 'd'}

print(other_set.issubset(my_set))  # False - потому что в наборе my_set
# нет эл. 'a', который присутсвует в наборе other_set

# а, если убрать из набора other_set - 'a', и использовать метод
# issuperset(), то вывод будет труе

print(my_set.issuperset(other_set))  # True
"""

"""my_set = {'f', 'd'}
other_set = {'d', 'f'}

print(my_set.issuperset(other_set))  # True
print(my_set.issubset(other_set))  # True

print(my_set == other_set) #True
# Потому что порядок следования эл. в наборах значения не играет
"""
"""
my_set = {"abc", 'd', 'f', 'y'}
other_set = {'a', 'f', 'd'}

print(my_set.difference(other_set))  # {'y', 'abc'}

# Получается, что мы от множества my_set отняли множество other_set,
# это равносильно тому, что мы использовали знак минус

print(my_set - other_set)  # {'abc', 'y'}
# {'f', 'd'} like method intersection - общие эл. в двух наборах
print(my_set & other_set)
# {'f', 'y', 'd', 'a', 'abc'} находим все эл. в двух множеств. -union
print(my_set | other_set)

print(my_set.discard('d'))  # None этот метод всегда возвращ. нон, ну
# и после этого, ниже исчех эл. 'd', таким образом можно
# удалять эл. из наборов. если добавить в этод метод, эл. которого нет,
# то ошибки не будет, просто вернется оригинальный набор
# но если добавить remove('эл. которого нет в наборе), то будет ошибка
# my_set.remove('def') #KeyError: 'def'
# но если эл. есть
my_set.remove('abc') #remove удалит эл. из набора.
print(my_set)  # {'f', 'abc', 'y'}

# Два метода ремув и дискард, работают по разному, ремув выдаст ошибку
# если эл. который вы пытаетесь удалить нет в списке, а дискард не выдаст
# ошибки.
"""
"""
my_set = {"abc", 'd', 'f', 'y'}

copied_set = my_set.copy()

my_set.add('t')  # {'t', 'f', 'd', 'y', 'abc'}
copied_set.add('l')  # 'l', 'd', 'y', 'abc'}

# этот метод позволяет создавать независимый набор, который
# можно изменять,
# но теперь можно найти пересечение этих двух наборов
print(my_set & copied_set) #{'f', 'd', 'y', 'abc'} common elem


print(my_set, copied_set)
"""


# Method symmetric_difference
"""
my_set = {"abc", 'd', 'f', 'y'}

copied_set = my_set.copy()

my_set.add('t')  # {'t', 'd', 'y', 'abc'}
copied_set.add('l')  # 'l', 'd', 'y', 'abc'}

print(my_set.symmetric_difference(copied_set))  # {'t', 'l'} это те эл.
# которых нет в пересечении множеств

print(my_set.difference(copied_set))
"""

"""a = {"abc", "d", "f", "y"}
b = {"abc", "d", "f", "l"}

print((a | b) - (a & b))  # {'y', 'l'} equal below expression

# мы сначала объединяем а и би, а потом отнимаем пересечение двух наборов.

print(a.symmetric_difference(b)) #{'l', 'y'}
"""

# Наборы являются очень мощным инструментом для обработки данных,
# так как пайтон часто используется для обработки данных и для машинного обучения
# и это те сферы где наборы хорошо подходят.


# ===========================================
# 1. Создайте набор с нескольких эл. типа int
# 2. Добавьте в него еще один эл.
# 3. Создайте еще один набор с несколькими эл.,
# причем некоторые должны быть такими же как в первом наборе
# 4. Найдите общие эл. в двух наборах и поместите их в новый набор
# 5. Конвертируйте результирующий набор в список и выведите список
# в терминал.

"""new_set = {1, 2, 3, 4}
new_set.add(5)
print(new_set)

other_set = {1, 2, 3}

print(new_set.issuperset(other_set))
print(other_set.issubset(new_set))

dif_set = new_set.difference(other_set)
print(f"Dif_set: {dif_set}")

union_set = new_set.union(other_set)
print(union_set)

discarded_set = new_set.discard(other_set)
print(discarded_set)


common_set_items = new_set.intersection(other_set)
print(list(common_set_items))"""

# Диапазон - это упорядоченая неизменяемая последовательность эл.
# Диапазоны обычно используются в циклах,
# Диапазон - это экземпляр класса рендж.
"""
my_range = range(7)

print(type(my_range))  # <class 'range'>

print(my_range)  # range(0, 7)

print(list(my_range))  # [0, 1, 2, 3, 4, 5, 6]
"""
# Т.е. цифра в скобках это граница, которая не включается в список,
# т.е. генерируется последовательность целых чисел не включая цифру в
# скобках, в примере выше от 0 до 7 не включичетльно.
# Кроме этого можно указать начальное значение и конечное,
# Также можно указать шаг.

"""my_range = range(10, 20, 3)

print(type(my_range))  # <class 'range'>

print(my_range)  # range(10, 20, 3)

print(list(my_range))  # [10, 13, 16, 19]
"""
# В примере выше 3 это шаг с которомым формируется шаг с диапазоном,
# т.е. создастся объект, который является экземпляром класса рендж и
# этот объект будет содержать список начиная с первой цифры, в нашем
# случае цифры 10 и заканчивая второй цифры, в нашем случае цифры 20,
# с шагом трейтьей цифры, в нашем случае цифры 3.

# Индексы эл. в диапазонах

"""my_range = range(10, 20, 3)

print(my_range[0])  # 10
print(my_range[1])  # 13
print(my_range[2])  # 16
print(my_range[3])  # 19
print(my_range[4])  # IndexError: range object index out of range
"""
# Если попытать обратиться к эл. который выходит за
# рамки максимального количества индекса, мы получим ошибку вышепреведенную
# В примере выше указанно как можно провести доступ к эл.
# через индекс.

# Диапазоны обычно искользуются в циклах
# Использвание диапазонов в циклах
"""
my_range = range(10, 20, 3)

for n in my_range:
    print(n)
    # 10
    # 13
    # 16
    # 19

new_range = range(30, 40, 2)
print(new_range)  # range(30, 40, 2)
print(new_range[2])  # 34
print(list(new_range))  # [30, 32, 34, 36, 38]
"""
# Диапазон используется для того, чтобы выполнять однотипные
# действия с эл. в определенном диапазоне.
# К примеру, если диапазон 100, то создастся диапазон эл.
# от 0 до 99 и мы можем выполнять однотипные действия с этими эл.

# Practice
"""
my_range = range(7)

print(type(my_range)) #<class 'range'>

print(my_range[1]) #1

for n in my_range:
    print(n)
    #1
    #2
    #3
    #4
    #5
    #6
"""
"""
for n in range(5):
    print(n)
    # 0
    # 1
    # 2
    # 3
    # 4
"""
"""
for n in range(2, 7):
    print(n)
    # 2
    # 3
    # 4
    # 5
    # 6
"""
"""
for n in range(12, 25, 5):
    print(n)
    # 12
    # 17
    # 22
"""
"""
print(list(range(12, 25, 5)))  # [12, 17, 22]
print(tuple(range(12, 25, 5)))  # (12, 17, 22)
print(set(range(12, 25, 5)))  # {17, 12, 22}
print(dict(range(12, 25, 5)))  # TypeError: cannot convert dictionary
#update sequence element #0 to a sequence
"""

# Methods and atributes of range
"""
my_range = range(5, 25, 3)
print(dir(my_range))

['__bool__', '__class__', '__contains__', '__delattr__',
 '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
 '__getattribute__', '__getitem__', '__getstate__',
 '__gt__', '__hash__', '__init__', '__init_subclass__',
 '__iter__', '__le__', '__len__', '__lt__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__',
 '__reversed__', '__setattr__', '__sizeof__', '__str__',
 '__subclasshook__', 'count', 'index', 'start', 'step',
 'stop']
"""

# atributes

"""
my_range = range(5, 25, 3)
print(my_range.start)  # 0
print(my_range.step)  # 3 - shows the step
print(my_range.stop) #25 show the finish
print(my_range.)
"""

# Methods
"""
my_range = range(10, 30, 3)

print(my_range.index(13))  # 1 index of the first eterated el


print(my_range.count(10))  # 1, shows that this el exists in range


print(my_range.count(11))  # 0
"""

"""
my_range = range(10, 50, 5)


my_list = []

for n in my_range:
    my_list.append(n)


print(my_list) #[10, 15, 20, 25, 30, 35, 40, 45]
"""

# Последовательности: сравнение типов

# list(СПИСОК) = изменяемые, важен порядок эл. и следовательно
# у каждого эл. есть свой уникальный индекс и в списках допускаются
# одинаковые эл. (ИЗМЕНЯЕМЫЕ, УПОРЯДОЧЕННЫЕ, ДОПУСТИМЫ ОДИНАКОВЫЕ ЭЛ.)

# tuple(кортежи) = (НЕИЗМЕНЯЕМЫЙ, ВАЖЕН ПОРЯДОК, ДОПУСТИМЫ ОДИНАКОВЫЕ ЭЛ.),
# У эл. есть индекс.

# set(набор) = (ИЗМЕНЯЕМЫЙ, ПОРЯДОК НЕ ВАЖЕН, НЕ ИМЕЕТ ОДИНАКОВЫХ ЭЛ.)
# Наборы поддерживают Добавление, Удаление новых эл. при этом в наборах
# порядок не важен, пайтон сам решает в какой Последовательности добвлять
# эл., поэтому сравнивая наборы у которых эл. расположены по-разному, но эл.
# одинаковые и их кол-во тоже одинаковое, мы получим результа Истина,
# такие наборы одинаковы в понимании пайтона, но в наборы нельзя добавлять
# одинаковые эл.

# range(Диапазон) = (НЕИЗМЕНЯЕМЫЙ, ПОРЯДОК ВАЖЕН, НЕ ДОПУСТИМЫ ОДИНАКОВЫЕ ЭЛ.)
# У эл. есть уникальные индексы в диапазоне, не допустимы одинаковые эл.
# потому что создается определенный шаг перебора, по умолчанию этот шаг 1,
# но мы можем изменять его на другое значение, но это в любом случае
# целое число.

# dict(СЛОВАРИ) =  (ИЗМЕНЯЕМЫЕ, ПОРЯДОК НЕ ВАЖЕН, НЕ ДОПУСТИМЫ ОДИНАКОВЫЕ ЭЛ.)
# их можно изменять, добовляя пару ключ:значени, также как и удалять,
# если сравнивать два словоря с одинаковыми эл. но с разной
# Последовательностью, то такие словари считаются одниковыми.
# Но, при этом в словаре не может быть одинаковых эл., каждый
# эл. уникален. Если мы напишем ниже новое значение для определенного
# ключа, то старое значение будет перезаписано.

# str(строка) = (НЕИЗМЕНЯЕМЫЙ, ПОРЯДОК ВАЖЕН, МОГУТ ПРИСУТСТВОВАТЬ ОДИНАКОВЫЕ ЭЛ.)
# Строка неизменяемый объект, но можно создавать новые строки, на основании существующих
# порядок важен, а следовательно каждый символ в строке имеет свой
# уникальный индекс и можно получить первый символ строки используя
# символ 0. По строкам можно выполнять итерацию и например конвертировать
# строку в список и в списке будет определенное кол-во символов.


# Вывод:
# Если нам нужена Последовательность уникальных эл. то лучше
# всего подойдет НАБОР

# Если нам необходимо хранить большое кол-во эл. у которых есть
# свой уникальный индетификатор (ключ), то подходит, конечно же,
# словарь для этих целей

# Если нам необходима просто упорядоченная Последовательность,
# при чем эл. могут быть разных типов, эл. могут повторяться,
# то лучше всего подходит СПИСОК.

# Если нам необходимо сформировать набор данных, в котором
# нельзя будет добавлять или удалять новые эл., то
# лучше подойдет КОРТЕЖ.

# Если необходимо выполнить определенное действие Н-количество
# раз, то для этих целей можно воспользоваться диапазоном.

# Ну, а стороки, чтобы создавать коротки или длинные строки.

# Типы Последовательностей очень хорошо конвертируются друг в друга,
# в случае если нам к примеру нужно будет изменить кортеж, который
# является неизменяемым, в таком случае нам следует конверт. кортеж
# в списко, изменить его, и конверт. обратно. Но, этого
# следует избегать, так как это будет означать, что мы подобрали
# неправильно формат данных для значений, если нам все-таки приходится
# изменить кортеж.


# Встроенная функция зип

# С помощью этой функции можно формировать новые объекты на основании
# других последовательностьей. Т.е объединять последовательности вместе.
# Пример:

"""
fruits = ['apple', 'banana', 'lime']
quantities = [100, 70, 50]

fruit_qtys_zip = zip(fruits, quantities)

print(fruit_qtys_zip)  # <zip object at 0x76f086012980>


print(type(fruit_qtys_zip)) # <class 'zip'>

fruit_qtys_zip = list(fruit_qtys_zip)

print(fruit_qtys_zip) #[('apple', 100), ('banana', 70), ('lime', 50)]
"""

# Т.е в примере выже мы создали пары, так можно объединять
# данные полученные из разных источников, к примеру фрукты
# мы получили из одного источника, а цены из другого, при этом
# эти данные можно будет объединить. Мы получаем ай ид нового
# эл., который в свою очередь можно конвертировать в список кортежей.
# ну а после можно выполнить итерацию по этому списку, выполняя
# определенные действия с каждым из эл.

# Если добавить эл. в один из слияемых объекта, то эл. который не
# имеет пару будет проигнорирован, вернутся только парные эл.
# Зип объект формируется на основании самого короткого списка,
# который мы передаем в функцию зип.

# Но, если создать третий эл. и попытать его соединить в функции зип,
# то мы получим список кортежей состоящий из 3 эл.


"""
fruits = ['apple', 'banana', 'lime']
quantities = {100, 70, 50}  # Порядок при этом не сохраняется., так
# лучше наборы не объединять. Потому что последовательность не гарантируется.
new_str = '1234' #Здесь мы получим числовое значение цифр
availability = (True, False, False)


fruit_qtys_zip = zip(fruits, quantities, availability, new_str)

listed_fruits = list(fruit_qtys_zip)

print(listed_fruits)"""

# [('apple', 50, True, '1'), ('banana', 100, False, '2'), ('lime', 70, False, '3')]
# Такая конвертация срабатывает, даже если типы объектов разыне.
# При этом мы даже можем конвертировать в кортеж, при этом
# мы получим кортеж в кортеже.

# Что будет если зип объект конвертировать в словарь.


# fruits = ['apple', 'banana', 'lime']
# quantities = {100, 70, 50}


# fruit_qtys_zip = zip(fruits, quantities)

# dict_fruits = dict(fruit_qtys_zip)

# print(dict_fruits)  # {'apple': 50, 'banana': 100, 'lime': 70}


"""мы получим словарь с тремя ключами. Но при этом, мы обязательно
должны передавать только 2 переменные из которых и будет формироваться
ключи и значение, передача большего количества приведет к ошибке.
Так мы смогли объединить две последовательности разных типов
список и кортеж в словарь
"""

# ==================================================

# Задание:

# Создать два списка в одном из которых должны быть названия товаров,
# а во втором будут цены этих товаров. Следует объединить два списка
# используя функцию зип. а после следует конвертировать результат сначало
# в список, а потом в словарь. И результаты конвертации следует вывести в
# терминал.
"""
name_of_goods = ["addidas", 'nike', 'guchi']
prices_of_goods = ['$12', '$15', '$30']

ziped_goods = zip(name_of_goods, prices_of_goods)

dicked_goods = dict(ziped_goods)

print(dicked_goods)  # {'addidas': '$12', 'nake': '$15', 'guchi': '$30'}
"""


# =====================================================================
"""
Изменяемые объекты в Пайтон

Адреса Неизменяемых объектов
"""
# my_number = 10
# print((id(my_number)))  # 10751144

# other_number = 10
# print(id(other_number))  # 10751144

# print(id(10))  # 10751144

"""
Если присвоить значение другим переменным, айди остается тотже.
Это означает, что в случае использования неизменяемых объектов
Пайтон создает объект только один раз в памяти. Что видно из
примера выше. И если мы создаем изначально один объект, а после захотим
присвоить это такое же значение другой переменной, то
пайтон найдет первый объек в памяти и даст новой переменной
просто ссылку на объект, который у нас уже существует. Так
Пайтон выполняет действия, которые касаются неизменяемых объектов.

Теперь, что происходит, если мы копируем неизменяемые объекты.
"""
# first_num = 10
# second_num = first_num

# print(id(first_num))  # 10751144
# print(id(second_num))  # 10751144

# # В примере выше, ссылка идет на один и тот же объект в памяти,


# second_num += 5
# print(second_num)  # 15
# print(first_num)  # 10

# print(id(second_num))  # 10751304
# print(id(first_num))  # 10751144
"""
А, в примере выше, явно видно, что айди изначально созданного
значения не поменялось, а измененное значение поменяло свой айди,
что говорит нам, что был создан новый объект, с новый айди.
Это все происходит только с неизменяемыми объектами,
"""


# Адерса Изменяемых объектов

# my_list = [1, 2, 3]
# print(id(my_list))  # 125540482678528

# other_list = [1, 2, 3]
# print(id(other_list))  # 125540480647872

# print(id([1, 2, 3]))  # 125540480648512
"""
В Изменяемых объектах дело обстоит совсем по-другому,
каждый раз при создании изменяемого объекта, создается новый
объект с новым айди. Это происходит потому, что списки это
изменяемые объекты в памяти и каждый новый объект списка можно
изменять независимо от других.

Что произойдет если добавить один эл. в список.
"""

# my_list = [1, 2, 3]
# print(id(my_list))  # 125540482678528

# other_list = [1, 2, 3]
# other_list.append(4)
# print(other_list)  # [1, 2, 3, 4]
# print(id(other_list))  # 129575565738624

# print(id([1, 2, 3]))  # 129575565740800

"""
В примере выше, мы присваеваем одинаковые списки, но не
копируем переменные. В таком случае изменения одного объекта не отражаются
на другом. Потому что мы создаем каждый раз новый объект.
"""

"""Dict (Словари)

Это также изменяемые объекты.
"""

# info = {
#     'name': 'Maksim',
#     'is_software_engenire': True
# }

# print(id(info))  # 132526498592064

# copy_by_ref = info
# print(f"copy by ref: {id(copy_by_ref)}")  # 132526498592064

# copy_by_ref['review_qty'] = 5

# print(id(copy_by_ref))  # 132526498592064

"""В примере выше, объет остается тотже, копируется только ссылка.
Даже если мы добавляем новый эл. и изменяем объект изначально созданный
Также изночально созданный словарь, изменит свое значение, в
него будет автоматитески добавлен новый эл."""

# print(copy_by_ref)  # el. added = 'review_qty': 5
# print(copy_by_ref['review_qty'])  # 5
# print(info['review_qty'])  # 5

# Добавится эл. выше приведенный.

"""В примере ниже создается новая ссылка, новый объект с новым айди."""

# info_copy = {
#     'name': 'Maksim',
#     'is_software_engenire': True
# }

# print(id(info_copy))  # 138840692033088


"""Получается, что мы можем изменять объект используя одну из переменных.
Теперь допустим, что мы хотим изменить словарь, но
теперь уже другую переменную словаря info_copy и теперь мы хотим
поменять количество review_qty на 100. """

# info_copy["review_qty"] = 100
# print(info_copy)
# print(id(info_copy))


# info = {
#     'name': 'Maksim',
#     'is_software_engenire': True
# }

# info_copy = info
# info['reviews_qty'] = 5
# info_copy['reviews_qty'] = 100

# print(info['reviews_qty'])  # 100
# print(info_copy['reviews_qty'])  # 100

"""Еще один пример в котором мы не присваеваем словарь, а копируем
его в др. переменную. В этом случае создастся два разных объекта
в памяти с разными айди и изменять эти объекты можно независимо друг
от друга. Если мы добавим эл. в любой из объектов, др. объект
останется без изменений. потому, что эти словари никак не связаны друг
с другом. И это все происходит потому, что словари это изменяемые
объекты в пайтон.
"""

# my_info = {
#     'name': 'Maksim',
#     'is_software_ingener': True
# }

# other_info = {
#     'name': 'Maksim',
#     'is_software_ingener': True
# }

"""Вывод:
После копирования изменяемых объектов изменения отражаются на всех
копиях. Т.е. если у нас есть 1 объект, который изменяемый и на
него ссылаются много переменных, то меняя этот объект через любую
из этих переменных мы получаем ситуацию в которой меняются все переменные,
которые указываются на этот объект в памяти. """


# Как избежать изменений копий.
# Чтобы не изменять оригинал, можно воспользовать приведенным
# ниже методом копи(), но если у словаря есть вложенные словари,
# то ссылки на них сохраняются.

"""info = {
    'name': 'Maksim',
    'is_software_engenire': True
}

info_copy = info.copy()

info['reviews_qty'] = 5

print(info_copy)  # {'name': 'Maksim', 'is_software_engenire': True}

# {'name': 'Maksim', 'is_software_engenire': True, 'reviews_qty': 5}
print(info)"""


# Пример с вложенным объектом.


"""В примере ниже, копируются все ключи словаря, но при этом,
если у ключей значения изменяемые объекты, то ссылки копируются
без изменений. т.е. ссылка на reviews скопируется без изменений.
т.е. получается копи нам дает копирование только первого уровня,
а др. уровни, в нашем случае словарь остаются без изменений.
и теперь если мы используя вторую переменную инфо.копи изменим
значение для ключа ревьюс путем добавления эл. в список методом
аппенд, то мы изменим и изначальный объект инфо.

Поэтому копи следует использовать очень аккуратно, чтобы не повредить
изменяемые типы. А, такие типы как кортежи, строки, целые числа допускается
применение метода копи, где можно быть уверенным, что мы не изменем
изначально созданный объект. потому что будут созданны полностью неза
висимые объекты, без одинаковых ссылок внутри. Но, если там есть
изменяемые объекты и если мы планируем изменить один из эл. , то
у нас будет изменяться и оригинальный объект. Но в пайтон есть
метод решения этой проблемы. Для этого можно использовать одну из
библиотек.
"""
# info = {
#     'name': 'Maksim',
#     'is_software_engenire': True,
#     'reviews': []
# }

# info_copy = info.copy()

# info_copy['reviews'].append('Great work!')

# print(info)
# #{'name': 'Maksim', 'is_software_engenire': True, 'reviews': ['Great work!']}

# print(info_copy)
# #{'name': 'Maksim', 'is_software_engenire': True, 'reviews': ['Great work!']}


# Как избежать изменений копий.

"""Встроенных методов для словарей, которые выполняют такие задачи нет,
потому можно воспользоваться встроенным в пайтон модулем, который
называется копи. и из этого модуля можно импортировать встроенныю
функцую диипкопи. Так мы можем копировать вложенные словари,
при этом оригинальный объект не будет изменяться. """

# info = {
#     'name': 'Maksim',
#     'is_software_engenire': True,
#     'reviews': []
# }

# info_deepcopy = deepcopy(info)

# info_deepcopy['reviews'].append('Great work')

# print(info_deepcopy)
# #{'name': 'Maksim', 'is_software_engenire': True, 'reviews': ['Great work']}
# print()

# print(info) #{'name': 'Maksim', 'is_software_engenire': True, 'reviews': []}

# Поверхностная копия называется shallow copy.
# =============================================================

# functions

# Функция это блок кода, который можно выполнять многократно.

"""
def sum(a, b):
    c = a + b
    print(c)


a = 5
b = 3

sum(a, b)  # 8

a = 8
b = 12

sum(a, b)  # 20


def my_fn(a, b):
    a = a + 1
    c = a + b
    return c
"""
# если не добавить ретерн, то функция в любом случае вернет
# значание, а значение будет None.

"""
print(my_fn(33, 99))  # 133


def my_fn2(a, b):
    a = a + 1
    c = a + b
    return c

# Можно присвоить результат новой переменной, как показано внизу.


res = my_fn2(10, 3)
print(res)  # 14
"""

# Функция прекращает свою работу, после того как вернет результат
# и все что идет ниже ретерн в теле функции.

# Самая короткая функция с именем:
# Используется ключевое слово pass, это слово ставится в тело
# функции, когда еще нет тела функции, но согласно правилам Пайтон
# в теле функции должна быть хотя бы одна строка кода. В случаях, когда
# мы еще не знаем как будет выглядеть функция, мы можем добавить
# ключевое слово пасс. Также пасс можно использовать в циклах,
# после того как мы определились, что должна выполнять функция, мы
# можем удалить ключевое слово пасс и вставить в него код.
"""
def my_fn():
    pass


print(my_fn)  # None
"""


# Передача неизменяемых объектов.
"""
def my_fn(a, b):
    a = a + 1
#Выше мы создали новый объект в памяти, старый при этом не меняется.
#потому что интеджер неизменяемый объект.
    c = a + b
    return c


num_one = 10
num_two = 5

res = my_fn(num_one, num_two)
print(res)
print(num_one)
"""

# Передача изменяемых объектов.

# В примере ниже, мы изменяем словарь через функцию,
# при этом значение айдж у оригинального словаря изменится тоже.
# потому что это изменяемый объект и здесь происходит изменение
# по ссылке на оригинальный объект.

# Внутри функции не рекомендуется изменять внешние объекты. Но, это
# может произойти неявно для нас, потому что если мы передаем в параметры
# функции изменяемый объект, то мы внутри функции работаем с параметрами
# функции, мы не меняем внешние преременные по именам этих внешних преременных
# мы меняем параметры функции, но при этом если мы работаем с изменяемыми
# объектами, то внешние переменные также изменятся.

"""
def increase_person_age(person):
    print(id(person))  # 140015018534016
    person['age'] += 1
    return person


person_one = {
    "name": 'Bob',
    "age": 21
}

increase_person_age(person_one)
print(person_one['age'])  # 22
print(id(person_one))  # 140015018534016 адрес тотже.
"""

# Как избежать изменения внутри фунции внешних объектов, это
# можно сделать путем создания копии объекта.

# Копии можно создавать как внутри функции, так и до вызова функции.
# Как показано ниже, или же в вызове функции (person_one.copy), но
# предпочтительнее делать это внутри функции, чтобы всегда при вызове
# функции создавалась копия объекта. Но, метод копи, как мы говорили
# раньше, создает только поверхностную копию объекта = Sellow copy., т.е.
# этот метод не влияет на вложенные объекты. Но, если у нас есть
# вложенные объекты, или же списки, или др. измен. объекты, то рекомендован
# но использовать дикт копи.

"""
def increase_person_age(person):
    person_copy = person.copy()
    person_copy['age'] += 1
    return person_copy


person_one = {
    'name': 'Bob',
    'age': 21
}

new_person = increase_person_age(person_one)
print(new_person['age'])  # 22
print(person_one['age'])  # 21
"""

"""Задача.

1. Создайте функцию merge_list_to_dict

2. у функции должно быть два параметра

3. Функция должна объединять два списка,
исользуя встроенную функцию zip.

4. Конвертируйте объект зип в словарь и верните его из функции.

5. Вызовите функцию, передав ей два списка в качестве аргументов.

6. Выведите результат вызова функции в терминал. """

# my desision:
"""
def merge_list_to_dict(a, b):
    new_dict = zip(a, b)
    return dict(new_dict)


new_list = [1, 3, 4, 5]
another_list = [True, "Hello"]

print(merge_list_to_dict(new_list, another_list))
"""
# Bogdan's desision.

"""
def merge_lists_to_dict(list_one, list_two):
    zipped_seq = zip(list_one, list_two)
    return dict(zipped_seq)


res_one = merge_lists_to_dict(['a', 'b', 'c'], [10, True, []])
print(res_one)  # {'a': 10, 'b': True, 'c': []}

res_two = merge_lists_to_dict(['abc'], [{}, True, 100])
print(res_two)  # {'abc': {}}

# res_three = merge_lists_to_dict([{}, True, 100], ["abc"])
# print(res_three) #TypeError: unhashable type: 'dict',
# Ошибка из-за того, что Пайтон не может создать хеш, на основании
# словаря. Т.е. ключем не может быть пустой словарь.

res_three = merge_lists_to_dict([10, True, 100], ["abc"])
print(res_three)  # {10: 'abc'}
"""

# Аргументы Функций.

# Аргументы есть не только позиционные, но и именнованные или
# агрументы с ключевыми словами -key words arguments. Также,
# количество арг. в вызове функций, также играет роль. Также,
# можно объединять аргументы в словарь внутри функции.

"""def my_fn(a, b): #parametrs Это позиционные параметры и арг.
    a = a + 1
    c = a + b
    return c

    При несоответсвии кол-ва арг. к параметрам(больше или меньше)
    мы получим ошибку.

my_fn(10, 3) #arguments.
"""

# может ли функция принимать любое кол-во аргументов - ДА.
# Это возможно тогда, когда мы объединяем аргументы в картеж
# В случае если передать пустой блок с аргументами, то фунция вернет
# нам 0, но если мы попытаемся получить доступ к индексу картежа, который
# по сути является пустым, то мы получим ошибку.


"""def sum_nums(*args):
    print(args) #(2, 3, 7)
    print(type(args)) #<class 'tuple'>
    print(args[0]) #2, если в арг. будет пусто, то из-за этого кусочка кода,
    # получим ошибку.
    return sum(args)


print(sum_nums(2, 3, 7)) #12, будет 0, если будет пустой блок в арг.
"""

# Позиционные Аргументы.

"""
def get_posts_info(name, posts_qty):
    info = f"{name} wrote {posts_qty} posts"
    return info


info = get_posts_info("Maksim", 25)#Позиционные арг. Порядок арг. важен.

print(info) #Maksim wrote 25 posts
"""

# Аргументы с ключевыми словами.

"""
def get_posts_info(name, posts_qty):
    info = f"{name} wrote {posts_qty} posts"
    return info


# Порядок не важен. Такой вариант, делает код более читабельным
# Допускается применение и позиционных арг и с ключевыми словами,
# при этом аргумент с ключевым словом будет присвоин эквиваленту
# в параметре функции, а оставшийся арг будет присвоин другому парамтру
# в соответсвии с позицией.
info = get_posts_info(posts_qty=25, name="Maksim, Levanovich")

print(info)  # Maksim, Levanovich wrote 25 posts
"""

# Объединение аргументов в словарь Dict
# В отличии от кортежа, в словаре нужно использовать оператор
# две звездочки ** в отличии от кортежа.

"""
def get_posts_info(**person):
    print(person) # {'name': "Maksim", "posts_qty": 25}
    print(type(person))  # <class 'dict'>
    info = (
        f"{person['name']} wrote " #Если не ставить здесь запятую,
        # Пайтон автоматически объединит две строки.
        f"{person['posts_qty']} posts"
    )
    return info


info = get_posts_info(name='Maksim', posts_qty=25)
print(info)  # Maksim wrote 25 posts
"""

"""
def get_posts_info(**person):
    print(person)  # {'posts_qty': 30, 'name': 'Maksim', 'id': 35}
    info = f"{person['name']} wrote {person['posts_qty']} posts"
    return info


info = get_posts_info(posts_qty=30, name="Maksim", id=35)  # если ключи не
# будут совпадать именем в параметре, то будет ошибка, но можно использовать
# метод get.
print(info)  # Maksim wrote 30 posts
"""
# Но в случае использования оператора две звездочки, который
# объединяет все аргументы в словарь, мы не имеем право передавать
# хотя бы один позиционный аргумент, иначе мы получим ошибку. в нашем
# случае выше, если в первом аргументе оставить только цифру 30,
# то мы получим ошибку.

# Task
"""
1. создайте функцию update_car_info, в которой все
именованные агрументы будут объединяться в словарь car.

2. Довавьте в словарь новый ключ is_available с
значением True

3. Верните из функции измененный словарь

4. Вызовите функцию с именованными аргументами
brand and price, их значения могут быть любыми.
"""

# my virsion:
"""def update_car_info(**cars):
    info = f'brand: {cars["brand"]}: price: {cars["price"]} is_avalable: {cars["is_avalable"]}'
    return info

info = update_car_info(brand="BWM", price=1500, is_avalable=True)

print(info)
"""

# Bogdan's version

"""
def updated_car_info(**car):
    car['is_avalable'] = True
    return car


print(updated_car_info(brand='BWM', price=10000))
# {'brand': 'BWM', 'price': 10000, 'is_avalable': True}
"""

# print(updated_car_info("BWM", 10000)) #TypeError: updated_car_info()
# takes 0 positional arguments but 2 were given(Потому что из-за
# синтексиса две звездочки**, не возможно передача позиционных объектов,
# т.к. этот синтаксис объединяет все объекты с ключевыми словами в
# один словарь, поэтому так функцию вызывать нельзя.)

"""1. Перепешите вызов функции merge_lists_to_dict из предыдущей задачи
так, чтобы в нем использовались аргументы с ключевыми словами.

2. Добавьте еще один выхов функции, в котором будет один позиционный
аргумент, а второй - аргумент с ключевым словом.
"""

"""
def merge_list_to_dict(list_one, list_two):
    return dict(zip(list_one, list_two))


res_one = merge_list_to_dict(list_one=['a', 'b', 'c'], list_two=[10, True, []])
print(res_one)  # {'a': 10, 'b': True, 'c': []}

res_two = merge_list_to_dict(list_two=[{}, True, 100], list_one=['abc'])
print(res_two)  # {'abc': {}}

res_three = merge_list_to_dict(['a', True, 100], list_two=['abc'])
print(res_three)  # {'a': 'abc'}
"""
# res_three = merge_list_to_dict(list_two=['abc'], ['a', True, 100])
# print(res_three)  # SyntaxError: positional argument follows keyword argument
# Если сначала идет аргумент с ключевым словом, то будет ошибка.

# Stoped on 99 ex.

# Значение параметров функции по умолчанию

"""
def mult_by_factor(value, multiplier=2):
    return value * multiplier


print(mult_by_factor(10, 2))  # 20
print(mult_by_factor(5))  # 10
"""
# Значением по умолчанию также может быть вызов функц. пример ниже.

"""
def get_weekday():
    return date.today().strftime('%A')


def create_new_post(post, weekday=get_weekday()):
    post_copy = post.copy()
    post_copy['created_on_weekday'] = weekday
    return post_copy


initial_post = {
    'id': 243,
    'author': 'Maksim',
}

post_with_weekday = create_new_post(initial_post)

print(post_with_weekday)
# {'id': 243, 'author': 'Maksim', 'created_on_weekday': 'Tuesday'}


print(initial_post)#{'id': 243, 'author': 'Maksim'} was not changed.

#Stopped on 101excesises Call back functions"""


# Call back functions:

# Колбяк функция это функция, которая передается как аргумент в
# другую функцию и там вызывается.
"""
def other_fn():
    # some actions...
    pass


def fn_with_callback(callback_fn):
    callback_fn()


fn_with_callback(other_fn)  # Здесь мы не вызываем функцию в параметре.
"""

"""
def print_number_info(num):
    if (num % 2) == 0:
        print("Entered number is even")
    else:
        print("Entered number is odd")


def print_square_num(num):
    print("Square of the num is", num * num)


def process_number(num, callback_fn):
    callback_fn(num)


entered_num = int(input("Enter any number:"))

process_number(entered_num, print_number_info)  # Entered number is even

process_number(entered_num, print_square_num)  # Square of the num is 1936
"""

"""
def send_data(data):
    # sending data to the remote server
    pass


def process_data(input_data, send_data_fn):
    updated_data = input_data.copy()
    # actions with updated_data
    send_data_fn(updated_data)


process_data({'name': 'Maksim'}, send_data)
"""
"""
Правила работы с функциями:

1. Называть функции исходя из выполняемых задач
2. Название функции начинать с глагола
3. Одня функция должна выполнять одну задачу, это повышает
читабельность кода.
4. Не рекомендуется изменять внешние
относительно фукнции переменные. Т.е. фукнкции должны быть
Чистыми функциями, т.е. одно из условий таких функций и
является, что она не должна изменять внешние переменные.
И при одинаковых вводных данных, т.е. когда мы вызываем функцию с
одинаковыми оргументами, она возвращает одни и тотже результат.
Такая функция и называется - чистой функцией.
И если заниматься отладкой програм, пайтон в том числе,
то как раз такая предсказуемость функций и используются для
того, чтобы писать различные тесты, атоматизированные тесты
нашего кода.
"""

# Документация функции. DOCSTRING - ИЗСПОЛЬЗУЮТСЯ ДЛЯ
# ДОКУМЕНТИРОВАНИЯ ФУКНКЦИЙ, КЛАССОВ, МОДУЛЕЙ.




from pathlib import Path
from os import path
import json
import _json
def mult_by_factor(value, mult=2):
    """Multiplies number by mltiplicator"""  # -DOCSTRING
    return value * mult


mult_by_factor(5)  # При наведении курсора на этот вызов,
# комментарий написанный выше отразится.


# def print_number_info(num):
#     """
#     Prints whether number is even or odd

#     Args:
#         num(int): Number to be evaluated,

#         такие комментарии можно генерировать автоматичски,
#         при помощи расширения autodocstring"""

#     if (num % 2) == 0:
#         print("Num is even")
#     else:
#         print("Num is odd")


# print_number_info(20)

# def print_number_info(num):
#     """
#     Prints num information

#     Args:
#         num (int): Interger number

#     Returns:
#         int: Same number

#         комментарий выше был сгенерирован автоматически,
#         мы напечатали три пары ковычек, а затем просто
#         нажали на таб и сгенерировался комментарий выше.
#         т.е. формируются блоки выше, как подсказки, что
#         нужно удалить, а на их месте оставить комментарий,
#         что этот блок кода выполняет.
#     """
#     if (num % 2) == 0:
#         print("Num is even")
#     else:
#         print("Num is odd")

#     return num


# print_number_info(20) #Наводим на вызов и получаем инфо выше.


# Области видимости - определяет границы действия переменной.
# В разных областях видимости можно создавать переменные
# с одинаковыми именами. Если мы захотим обратиться к переменной,
# которой нет в локальной области видимости, то пайтон будет
# искать переменную в глобальной облости видимости.
# Существуют Глобальные и Локальные переменные.
# Локальные переменные не доступны Глобальным, а вот глобальные
# переменные доступны локально например внутри функции.
"""
a = 10


def my_fn():
    a = True
    b = 15
    print(a) #True
    print(b) #15


my_fn()

print(a) #10
#print(b) - NameError: name 'b' is not defined
"""


# В примере ниже, значение переменной а была найдена
# локальной-внутренней функцией.
"""a = 5


def my_fn():
    def inner_fn():
        print(a)  # 5
    inner_fn()


my_fn()
"""

# ""Типы областей видимости.
# Есть всего два типа областей видимости,
# глобальная область видимости и Область видимости функции.
# В пайтоне нет области видимости блока кода, например
# если мы создаем инструкцию if и внутри инструкции есть
# определенные строки кода, которые выполняются если условие
# правдиво и в этом блоке мы создаем переменные, то эти
# переменные будут созданы снаружи if, например в глобальной
# облости видимости, либо же если иф находится внутри функции,
# то переменные будут созданы внутри области видимости функции. ""

# Жизненный цикл переменных.
"""
a = 10 # 1. Объявление "а" в глобальной области видимости и
# присвоение значения 10

def my_fn():
    a = True #3. Объявление "а" в области видимости функции
    # и присвоение значения True
    b = 15
    print(a) #True 4.Объявлена ли "а" в рамках функции? ДА,
    #Вывод значения "а" в терминал.
    print(b) #15
    # После этого выполнение функции заканчивается и как только
    # функция заканчивает свою работу все переменные,
    # которые были созданы в этой функции удаляются. т.е. область
    # видимости функции очищается. Но, есть случаии когда мы
    # возвращаем в качестве результата значение той или же иной
    # переменной и можем даже вернуть другую функцию из этой
    # функции, в таком случае некоторые переменные могут существовать
    # дальше, даже если функция закончила свою работу. Это называется
    # замыкание в программировании. Но в нашем случае выше, переменные
    # "а и б" будут удалены, как только функция закончит свою работу.
    # т.е. когда функция дойдет до последней строчки в теле
    # функции. Ну а после этого мы переходим к выводу значения
    # "а и б" в терминал, которые находятся вне функции.


my_fn() #2. Вызов функции

print(a) #10 - 5. Объявлена ли "а"  глобально? ДА,
# Вывод значения "а" в терминал
"""
# print(b) - Error здесь пайтон сначала ищет эту переменную
# глобально, а так как функция выше уже отработала и
# значение б было использованно и удаленно, то "б" будет
# ошибкой, так как глобально этой переменной не существует.
#

# Создание глобальной переменной в функции.

"""
def my_fn():
    global a  # Перем. "а" будет объявлена в глобальной области видимости.
    a = 10


my_fn()

print(a)  # 10

# Использование глобальной переменной в функции

a = 10 #это значение не будет учитываться функц. ниже


def my_fn():
    global a
    a = 15 #Приоритет у этой переменной.,но это будет сделано
    # только если эта функция будет вызвана, если не вызвана,то
    # будет выведенно значение выше.
#     Но, еще раз как напоминание, не рекомендуется изменять
#     внешние относительно функции переменные. Следует это делать,
# только в тех случаях когда нам реально это необходимо.


my_fn()

print(a)  # 15
"""

# Практика глобальных переменных.

# но, если объявить переменную снаружи функции, то она будет доступна
# для тела функции.
"""
c = 5


def my_fn(a, b):
    print(a, b)  # abc xyz
    print(c)  # 5


my_fn("abc", 'xyz')
"""
# print(b) - эта переменная не имеет доступа внутрь функции, будет ошибка.

# Как же можно найти название всех переменных, которые доступны в
# глобальной области видимости. Для этого есть функция dir

"""c = 5


def my_fn(a, b):
    print(a, b)  # abc xyz
    print(c)  # 5

# При вызове этого метода ниже, мы видим в числе магических методов
# "c" and "my_fn" - это те переменные, которые были созданы в глобальной
# области видимости.

print(dir())"""  # ['__annotations__', '__builtins__', '__cached__',
# '__doc__', '__file__', '__loader__', '__name__', '__package__',
# '__spec__', 'c', 'date', 'deepcopy', 'mult_by_factor', 'my_fn']

# Как найти локальные переменные - нужно dir поместить внутрь блока
# фукнции.
"""
c = 5


def my_fn(a, b):
    d = 10
    print(a, b)  # 3 5
    print(c)  # 5
    print(dir())  # ['a', 'b', 'd]- показал локальные переменные.


my_fn(3, 5)
"""

# Operators in Python

# a = 10  = оператор присовения.
# +, -, *, / #  арифметические операторы.
# ==, !=, <, > # Сравнения, результат True or False
# not, and, or = Логические операторы.
# not, and, or, is, is not, in, not in = текстовые операторы.

"""
a = 10
b = a

c = a + b
# с помощью оператора is можно проверить совпадают ли два объкта.
#объекты совпадают, если у них айди одинаковый
print(a is b)  # True - ссылка на один и тоже объект
# False - сгенерирован новый объект - целое число 20 у котого айди другой.
print(c is a)
print(c) #20
"""

# У операторов есть соответствующие магические методы классов.
"""
a = [1, 2]
b = [1, 2]

# эл. выше одинаковые, хотя если мы напишем выражение a is b, мы получим
# False, потому что создаются два разных объекта, так как объект изменяемый,
# айди у них будет разный, т.е. значения этих списков будет одинаковым,
# но объекты при этом имеют разные айди


print(a == b)  # True - порядок следования операндов важен, если
# мы поставим b перед а, то метод будет вызываться изходя из класса к
# которому принадлежит b.

print(a.__eq__(b))  # True - methond of expression above.

# ниже виден разные айди у объектов.
print(a.__eq__)  # <method-wrapper '__eq__' of list object at 0x740a2d13df00>
print(b.__eq__)  # <method-wrapper '__eq__' of list object at 0x74f701b41400>

print(hex(id(a))) #0x740a2d13df00>
print(id(a)) #126050222989056
"""

# function dir(list)
# print(dir(list)) Выводит список имен отрибуетов определенного объекта.

# Унарные и бинарные операторы.
# У унарных операторов всегда один операнд.

"""- my_number - при минусе можно поменять знак переменной

+ my_number - плюс показывает нам, что мы работаем с числом и
это число позитивное. также при помощи этого оператора можно конвертировать
логическое значение в целое число.

not is_activated - not это логический оператор отрицания, кроме него
можно использовать двойное отрицание not not, таким образом в Пайтон
можно конвертировать любое значение в пайтон в логическое False or True,
т.е. оценить его ложность."""
"""
my_num = 10

print(+ my_num)

my_bool = True  # if False результат ниже будет 0.
print(+my_bool)  # 1 - конвертировали True в целое число.,


my_num = 10

print(not my_num) #отрицание правдивого значение это False, а отрицание
# ложного значения дает нам True
"""
"""
Бинарные операторы:

a = 5 - оператор присвоения
a + b - оператор сложени, может быть использован для сложения списков и наборов
a+=5 - увеличение и присвоение значения
a == b - сравнение двух объектов
a and b

инфиксная запись
Оператор находится между операндами.

a = True
a + b
a+=5
a or b
a > b
"""

# Operators in, not in - проверяем присутсвие ключа в словаре

"""
my_car = {
    'brand': 'Toyota',
    'price': 10_000
}

print('brand' in my_car) #True
print('year' in my_car) #False
print('year' not in my_car) #True
"""

# Приоритетность операторов. Если операторов много, лучше использовать скобки()

"""a + b * c / d - e
a + ((b * c) / (d - e))
(((a + b) * c) / d) - e

также можно использовать таблицу, которую можно найти в гугле."""

# Task
"""
1. создайте две переменные и присвойте им одинаковые последовательности
типа set. При этом не копируйте одну переменную в другую.
2. Выведите в терминал результат сравнения двух созданных объектов,
объясните результат.
3. Сравните два объекта используйте оператор is, объясните результат.
4.Проверьте, есть ли определенные эл. в наборе, используя оператор in"""
"""
first_set = {"Maksim", "Anastasiya", "Lisa", "Katya"}
second_set = {"Katya", "Maksim", "Anastasiya", "Lisa"}

print(first_set == second_set)  # True сравниваются значения
print(first_set.__eq__(second_set)) #True

print(first_set is second_set)  # False сравниваются объекты

print("Maksim" in second_set)  # True
"""

# Ложные значения-это значение, которое при приведении к логическому
# типу дает False, является ложным и наоборот.
# Ложные значения.

# int 0, float 0.0, complex 0j.

# bool(value) - False or True - так можно определить ложное или нет.

# all False
"""
print(bool(0))
print(bool(0.0))
print(bool(0j))
print(bool(None))
dict{}
list[]
tuple()
set()
range(0)
str ""
print(not not {})

"""
"""print(bool(10))
print(bool({"a": 1}))
print(bool(["a"]))
# print(bool(not 10)) False
"""


# Ложные значения в условных инструкциях if
"""
my_list = [1, 2]

if len(my_list) > 0:  # но так не пишут, достаточно просто передать лист
    # и в зависимости от того, пустой он или же нет, мы получим результат
    # True or False
    print("List has elements")  # List has elements


print(bool(-1))#True
"""

# Логические операторы
"""not - Всегда возвращает значение типа bool, также всегда унарный и префексным.

Опереторы ниже, возвращают значения одного из операндов. т.е. они не конвертируют
результат в логическое значение, они возвращают значение одного из операндов. а вот
какой операнд используется для возврата значения зависит от ложности значения того
или иного операнда.
and
or


Оператор not чаще всего используется в условных инструкциях if, также можно
использовать два раза нот, это двойное отрицание и таким образом можно конвертировать
любое значение в логическое значение True or False. это аналогично встроенной функции bool

not 10 # False
not 0 # True
not 'abc' # False
not '' # True
not True # False
not None # True

Отрицание отрицания

not not 10 # True
not not 0 # False
not not "abc" #True
not not '' #False
not not True #True
not not None #False
но если нам нужно получить ложное или же истенное значение в if, то
необязательно использовать нот нот инструкцию, в случае передачи к примеру
числа 10, что является истинной в Пайтон, то при if оно будет восприниматься как
истина или ложь.

Операторы and и or. являются операторами короткого замыкания (short-circuit)

Оператор and это инфиксный бинарный оператор, у которого есть два операнда, которые
могут быть любые выражения. Если первое выражение ложно, то выражение 2 игнорируется и
результатом будет выведения выражения 1. т.е Пайтон оценит выражение 1 и вернет его
как результат всего выражения. Если выражение 1 правдиво, то нам вернется результат второго
выражения, не зависимо от того ложно это выражение или правдиво. т.е. возвращается
первое найденное ложное значение, если все правдивы возвращается последнее.

Оператор or - также является инфиксным, бинарным оператором. Если результат выражения
правдив, то результат всего выражения будет правдив. Если первое выражение истина, то
второе уже игнорируется и мы понимаем, что все выражение истина. Также как и в первом
случае, если все значения ложны, то вернется последнее выражение. и следовательно результат
всего выражение будет ложным и наоборот.

Заключение: в первом варианте где мы используем оператор and, если оба значения истина,
вернется результат выражение истина, если хотя бы одно из них ложно, то все выражение будет
ложно.

Цепочка операторов and и or.

a and b and c and d - первое значение будет результатом всего выражения

a or b or or d - первое правдивое значение будет результатом выражения.

a or b and c or d - в этом случае лучше использовать круглые скобки, чтобы
явно указывать приоритетность операторов.

Практика - Логические операторы.

my_list = []

print(not my_list) #True

my_list = [1, 2]

print(not my_list) #False

===============================

my_list = [1, 2]

other_list = ['a', 'b']

print(my_list or other_list) # [1, 2] was returned first True

# True - в этом случае первое значение будет True,
print(len(my_list) > 0 or other_list)
оно и вернется.

# ['a', 'b'] Retured first Truthy expression
print(len(my_list) < 0 or other_list)


Operaton and

my_list = [1, 2]

my_dict = {}

print(my_list and my_dict) # {}, retured first Falsy expression.

print(bool(my_dict and my_list)) # False.



===============================

"""
"""
list_one = ["List not empty"]
empty_list = ["List empty"]

print(list_one or empty_list) #['List not empty']

my_list = [1, 2]

my_list and print("List is not empty") #List is not empty
"""

"""Задание:

создать два словаря, у этих словарей должны быть одинаковые ключи
с одинаковыми значениями. порядок ключей при этом может быть разным.
далее используя характеристику оператора and следует вывести в
терминал текст Dictionaries are equal, если первый словарь равен второму
словарю"""
"""
first_dict = {"Maksim": True, "Anstasiya": True}
second_dict = {"Anstasiya": True, "Maksim": True}

print(first_dict == second_dict and "Dicts are equal")
"""

# Оператор распаковки словаря две здездочки **
"""этот оператор можно использовать для того, чтобы разделять словарь
на различные эл. и обратно в словарь.

button = {
    'width': 200,
    'text': 'Buy'
}

red_button = {
    **button,
    'color': 'red' #но если бы это значение было бы в словаре выше,
    # то это значение было бы перезаписано.
}

Синтаксис такой же как и в методе расширения, при этом оригинальный
словарь не изменился. Все ключи словаря выше, были добавлены в
словарь ниже.

print(red_button) #{'width': 200,'text': 'Buy', 'color': 'red'}

print(button) #{width': 200, 'text': 'Buy'}
"""
"""
grey_button = {
    'width': 200,
    'text': 'Buy',
    'color': 'grey'
}

red_button = {
    'color': 'red',
    **grey_button,
}

print(red_button) #{'color': 'grey', 'width': 200, 'text': 'Buy'}

print(grey_button) #{'width': 200, 'text': 'Buy', 'color': 'grey'}

в таком варианте - колор грей теперь у обоих словарей,
потому что мы сначала добавили в ключ колор с значением ред,
а потому перезаписали его парой ключ - значение из первого словаря,
который мы распоковали из словаря грей_батн. Поэтому, чтобы не изменять
первый словарь, следует сначала ставить значение с операторами
ключ с двумя звездочками, а после остальные значения. Потому что
порядок следования строк в данном случае важен.
"""

# Объединение словарей с помощью оператора распаковки **

"""
button_info = {
    'text': 'Buy'
}

button_style = {
    'color': 'yellow',
    'width': 200,
    'height': 300,
}

button = {
    **button_info,
    **button_style,
}

print(button)"""

# {'text': 'Buy', 'color': 'yellow', 'width': 200, 'height': 300}
"""При таком копировании учитывается последовательность переданных в
словарь батн ключей, если в элементах будут одинаковые ключи, но
с разными значениями, то значение последнего ключа будут являться
приоритетным. Но, есть более простой способ объединения словарей,
способ ниже. """

"""button_info = {
    'text': 'Buy'
}

button_style = {
    'color': 'yellow',
    'width': 200,
    'height': 300,
}

button = button_info | button_style #объединение словарей
оператор прямая черта - это оператор объединения, который также
можно использовать для словарей, как и в наборах. порядок следования
операндов также важен, процедура такая же как и указано выше,
последний имеет приоритет. его значение и будет записан.
эта функция появилась с приходом версии 3.9.0
при таком методе оригинальные словари также не меняются.

print(button)"""


# Пример ниже, приоритетность последних словарей в случае одинаковых
# ключей.

"""button_default = {
    'text': 'Ok',
    'color': 'black',
    'width': 0,
    'height': 0,
}

button_style = {
    'color': 'yellow',
    'width': 200,
    'height': 300,
}

button = button_default | button_style
print(button)
# {'text': 'Ok', 'color': 'yellow', 'width': 200, 'height': 300}
#color was replaced by 'yellow'."""


"""Задание

С помощью оператора прямая черта, либо же оператора распаковка словаря
объединить, три разных словаря. """
"""
husbend = {
    "Maksim": True
}

wife = {
    "Anastasiya": True
}

chidren = {
    "Yelizaveta": "Girl",
    "Yekaterina": "Girl",
    "Lev": "Boy"
}

family = husbend | wife | chidren

print(family)

#{'Maksim': True, 'Anastasiya': True,
# 'Yelizaveta': 'Girl', 'Yekaterina': 'Girl', 'Lev': 'Boy'}
"""

# =================================================

"""Инструкция del

Часто в Пайтон ее называют оператором, но это на самом деле инструкция.

При помощи дел, можно удалять определенные элементы из
последовательностей, например можно удалить элемент из словаря, по
названию ключа, либо можно удалить эл. из списка по индексу. """

# my_dict = {'a': True, 'b': 10}

# del my_dict['a']

# my_dict.__delitem__('b') #вызывается этот метод всегда, когда выз дел.

# print(my_dict)  # {}

# print(my_dict.__delitem__)
# #<method-wrapper '__delitem__' of dict object at 0x75f659612440>


# Соединение строк в Пайтон
"""
print("Hello " + "World")

hello = "Hello"
world = "World"

greetings = hello + ' ' + world

print(greetings)

# Форматирование строк
hello = "Hello"
world = "World"

greetings = f"{hello} {world}"

print(greetings)

name = "Maksim"
my_hobby = "running"
hour = 8

my_activities = f"{name} likes {my_hobby} at {hour} o'clock."
print(my_activities)
act_to_upper = my_activities.title()
print(act_to_upper)
"""

# lambda function

# lambda parameters: expression - всегда анонимная

"""
def lam_fun(a, b): return a * b


print(lam_fun(3, 5))
"""
# при присвоении лямбды функции переменной, у нас автоматически заменилась
# лямбда функция на обычную функцию - это сделал настройщик ПЕП 8, потому что не следует присваивать
# лямбду фукцию переменной.

"""
def greeting(greet):
    return lambda name: f"{greet}, {name}!"


morning_greeting = greeting("Good Morning")

print(morning_greeting("Maksim")) #Good Morning, Maksim!

evening_greeting = greeting("Good Evening")

print(evening_greeting("Maksim")) #Good Evening, Maksim!
"""
"""В примере выше показано ЗАМЫКАНИЕ, здесь у нас обычная функция
под названием greeting, у этой функции есть один параметр greet, и
внутри этой функции мы возвращаем лямбду фукнкцию, т.е. из одной
функции мы возвращаем другую функцию, эта лямбда функция имеет один
параметр name и внутри есть выражение с Ф строкой, т.е. мы форматируем
строку и возвращаем результат такого форматирования. И в этой Ф строке,
мы используем как параметры этой функции greet - greeting(greet), так
и параметр лямбда функции name - lambda name: f"{greet}, {name}", и
в итоге, когда мы вызовем функцию greeting, т.е. переменная morning_greeting,
будет теперь функцией и ее также можно будет вызывать, при этом, мы
сможем вызывать ее передавая ей разные имена, в примере
print(morning_greeting("Maksim")), т.е. здесь мы вызываем функцию
morning_greeting и передаю ей свое имя, и это будет значение для
параметра лямбда функции name и лямбда функция возвращает результат
этого выражения - f"{greet}, {name}!", т.е. на место greet - подставится
Good Morning, а на место name - подставится Максим и получается, что
в этом случае функция greeting уже завершила свою работу, но после
этого при вызове функции morning_greeting у нас внутри этой функции
все еще есть доступ к значению параметра greet, это параметр
функции greeting и это поведение называется ЗАМЫКАНИЕ в Пайтон. т.е.
хотя функция greeting уже завершила свою работу, но все равно для
функции лямбда в данном примере у нас есть доступ к параметру greet."""

"""
def greeting(greet):
    def info(name):
        return f"{greet}, {name}!"
    return info


morning_greeting = greeting("Good Morning")

print(morning_greeting("Maksim"))  # Good Morning, Maksim!

evening_greeting = greeting("Good Evening")

print(evening_greeting("Maksim"))  # Good Evening, Maksim!

# будет тот же результат, но лучше испльзовать при этом лямбду функцию.

hi_guys = greeting("Hello guys")
print(hi_guys("How are you?"))
"""

# Обработка ошибок
"""
print(10 / 0) #ZeroDivisionError: division by zero, если у нас возникает
подобная ошибка, то выполнение кода дальше не пойдет. и текст ниже,
мы в терминале не увидем. программа выше остановится на поиске результата
выражения, при этом даже не вернет нам результат, а вернет ошибку.
print("Continue...")
"""

"""Как же в Пайтон происходит обработка ошибок, для этого существует
ситексис try: except:
"""

"""try:
    #Выполнение блока кода
    pass
except ErrorType: #-здесь указывается какая именно ошибка должна быть поймана.
    #этот блок выполняется в случае возникновения ошибок в блоке try.
    pass
"""
"""
try:
    print(10/0)
except ZeroDivisionError:  # здесь указывается класс определенной ошибки.
    print("Error - Division by zero!")  # Error - Division by zero!

print("Continue...")  # Continue...


try:
    print(10/0)
except ZeroDivisionError as e:
    print(type(e))  # <class 'ZeroDivisionError'>

    print(dir(e)) #['__cause__', '__class__', '__context__',
    # '__delattr__', '__dict__', '__dir__', '__doc__',
    # '__eq__', '__format__', '__ge__', '__getattribute__',
    # '__getstate__', '__gt__', '__hash__', '__init__',
    # '__init_subclass__', '__le__', '__lt__', '__ne__',
    # '__new__', '__reduce__', '__reduce_ex__', '__repr__',
    # '__setattr__', '__setstate__', '__sizeof__', '__str__',
    # '__subclasshook__', '__suppress_context__', '__traceback__',
    # 'add_note', 'args', 'with_traceback']

    print(e)  # division by zero

print("Continue...")  # Continue...
"""

# Другие ошибки. В примере ниже, можно добавить еще один обработчик ошибок.
"""
try:
    print("10" / 0)
    # TypeError: unsupported operand type(s) for /: 'str' and 'int'

except ZeroDivisionError as e:
    print(e)
except TypeError as e:
    print(e) #unsupported operand type(s) for /: 'str' and 'int'
print("Continue...") #Continue...
"""

# Block else - этот блок кода будет выполняться, когда ошибок не возникло.

"""try:
    print(10/5)
except ZeroDivisionError as e:
    print(e)
except TypeError as e:
    print(e)
else: #этот блок кода выполняется только если ошибок не возникло.
    print("Trere was no error")
    #There was no error
finally: #этот блок выполняется в любом случае, независимо от ошибок.
    print("Continue...") # Continue...
"""

"""
К примеру если мы работаем с базой данных и нам необходимо
в блоке try подключиться к базе данных, выполнить определенные
действия и потом отключиться от базы данных, то отключение от
базы данных, конечно же, следует выполнять в блоке fanally независимо
от того, возникла ошибка или же нет. А, вот в блоке else следует
выполнять действия в случае если комуникация с сервером прошла успешно
и данные к примеру были успешно переданны на сервер и в блоке else
мы можем выполнить другие действия с этими же данными, потому что
мы знаем что никаких других ошибок в блоке try не возникло. """

# Отсутсвие типа ошибок и класс Exception
"""
try:
    print(10/0)
# Exception является род. классом для ZeroDivisionError класса и др.
except Exception as e:
    print(isinstance(e, ZeroDivisionError))  # True
    print(isinstance(e, str))  # False
    print(isinstance(e, Exception))  # True
    print(isinstance(e, object)) #True
    print(e)  # Division by zero

try:
    print(10 / 0)
except:
    print("Some error occurred")  # Some error occured
#не рекомендуется использовать пример выше, так как нет информации
# об ошибке.
"""
"""В реальной жизни большие приложения как правило состоят из
многих микросервисов, и зачастую ошибки не просто логируют в терминал,
потому что приложения могут работать на сотнях или же на тысячах
разных серверов и чистать то что выводится на каждом из серверов
никто не будет, обычно ошибки перенаправляются на внешние сервера
логирования и для этого используются различние сервисы как
внешине сервисы в облаке, так и можно создавать и собственные сервисы
логирования и одним из таких сервисов является logstash kibana и
с помощью этих сервисов можно настроить центролизированное сохранение
всех логов в том числе и ошибок, которые возникают в наших приложениях.
"""

# Создание ошибок. Генерация ошибок с помощью RAISE

"""
def divide_nums(a, b):
    if b == 0:
        raise TypeError("Second argument can't be 0")
    # но лучше в примере выше создать ошибку ValueError
    return a / b


try:
    divide_nums(10, 0)
except ZeroDivisionError as e: #этот блок теперь не нужен, т.к. сработает
    #блок ниже
    print(e)
except TypeError as e:
    print(e)
    # Second argument can't be 0

print('Continue...') #Continue...
"""

"""т.е. если у нас происходит деление на какое-либо значение и при
этом одно из значений будет 0, то лучше соответсвующую обработку
значений и генирацию ошибок добавить в функции, как показыно выше,
а не делать это уже вне функции при ее вызове. """


# Задача - обработка ошибок.

# 1. Создайте функцию image_info с одним параметром типа dict.

# 2. Функция ожидает словарь, в котором должно быть как минимум два ключа:
#  image_id:
#  image_title

# 3. Функция должна возвращать строку такого вида
# "Image 'my cat' has id 5136"

# 4. Если хотя бы одного из этих ключей в словаре нет,
# функция должна генерировать ошибку TypeError.

# 5. Вызовите функцию и корректнообработайте ошибку в случае возникновения.

"""
Мое решение:

dict_images = {
    "image_id": 5136,
    "image_title": "my cat"
}

empt_dict = {

}


def image_info(dict):
    if 'image_id' not in dict or 'image_title' not in dict:
        return TypeError("There is no image_id or image_title vulue")
    return dict


try:
    print(image_info(empt_dict))
except TypeError as e:
    print(e)
"""

# Bogdan's decision

"""
def image_info(img):
    if ('image_id' not in img) or ('image_title' not in img):
        raise TypeError("Keys image_id and image_title must be present")
    return f"Image '{img['image_title']}' has id {img['image_id']}"


print(image_info({'image_title': 'my cat', 'image_id': 123}))


# TypeError: Keys image_id and image_title must be present
# print(image_info({'image_title': 'my cat'}))

try:
    print(image_info({'image_title': 'my cat'}))
except TypeError as e:
    print(e)#Keys image_id and image_title must be present
"""

# Распаковка - извлечение значений и присвоение их переменным
"""
my_fruits = ['apple', 'banana', 'lime']

my_apple = my_fruits[0]
my_banana = my_fruits[1]
my_lime = my_fruits[2]

print(my_apple)
print(my_banana)
print(my_lime)

# Метод выше грамозский, и можно сократить его.

# Reminder - List, Tuple - упорядоченые последовательности эл.

my_fruits = ['apple', 'banana', 'lime']

my_apple, my_banana, my_lime = my_fruits

# Распаковка словарей - аналог в Деструктуризации массивов в JS
# нельзя использовать больше кол-во эл., чем в оригинальном списке.

print(my_apple)
print(my_banana)
print(my_lime)


# Такой же способ можно применять и кортежам.

my_fruits = ('apple', 'banana', 'lime')

print(type(my_fruits))  # <class 'tuple'>

my_apple, my_banana, my_lime = my_fruits


print(my_apple)
print(my_banana)
print(my_lime)

# Использование * при распаковке.

my_fruits = ['apple', 'banana', 'lime']

my_apple, *remaining_fruits = my_fruits

print(my_apple)  # apple - string
print(remaining_fruits)  # ['banana', 'lime'] - list

print(type(my_apple)) #<class 'str'>

print(type(remaining_fruits))  # <class 'list'>
"""

# Распаковка словаря в аргументы с ключевыми словами.
"""
user_profile = {
    'name': 'Maksim',
    'comments_qty': 23
}


def user_info(name, comments_qty=0):
    if not comments_qty:
        return f"{name} has no comments"

    return f"{name} has {comments_qty} comments"


print(user_info(user_profile["name"], user_profile["comments_qty"]))

print(user_info(name=user_profile["name"],
      comments_qty=user_profile["comments_qty"]))

print(user_info(**user_profile))
"""
# Все три варианта выше валидны. Но распаковка удобнее.


# Распаковка списка в позиционные аргументы.
"""
user_data = ["Maksim", 23]


def user_info(name, comments_qty):
    if not comments_qty:
        return f"{name} has no comments"
    return f"{name} has {comments_qty} comments"


print(user_info(*user_data))  # Maksim has 23 comments

# another variant

my_name, my_comments_qty = user_data

print(user_info(my_name, my_comments_qty)) #Maksim has 23 comments
"""

# Несовпадение количества аргументов нежели
# функция того ожидает приведет к ошибке к такой:
# TypeError: user_info() takes 2 positional arguments but 3 were given
# Но, мы всегда можем добавить блок try except, чтобы корректно обработать
# такую ошибку.


# Задание:

# создать список словарей и в нем будет к примеру 3 словаря,

# и далее с помощью оператора распоковки списков, следует создать,
# 3 переменных каждая из которых будет содержать один из словарей.

# Далее следует создать функцию, которая будет принимать два аргумента
# и в вызове функции мы должны распаковывать словарь.

# Функцию следует вызвать трижды, потому, что у нас в оригинальном списке
# было 3 словаря, следовательно у каждого из словарей должно быть по
# 2 ключа.
"""
my_family = [
    {"name": "Maksim",
     "age": 43},
    {"name": "Anastasiya",
     "age": 35},
    {"name": "Irina",
     "age": 65}
]

maksim = my_family[0]
anastasiya = my_family[1]
mom = my_family[2]


def get_details(name, age):
    return f"{name} is {age} years old!"


print(get_details(**maksim))
print(get_details(**anastasiya))
print(get_details(**mom))
"""

# Условные инструкции

# if,   if ...else,    if....elif, тернарный оператор - для Выражений
"""
if Условие:
    Блок кода, выполняемый однократно, если Условие правдиво.

Ниже как напоминание идут все ложные значения:

dict {}, list [], tuple (), set (), range (0), str "", int 0,
float 0.0, complex 0j,
bool False
NoneType None

not not - проверка на ложность значения.
bool(value) - также проверка на ложность значения

Правдивыми являются все неложные значения
"""
"""
my_number = 25

if my_number > 0:
    print(my_number, "is positive number ")


person_info = {
    'age': 20
}

if not person_info.get('name'):  # Результат выражения с оператором not,
    # и ложным операндом всегда True
    # Действия в случаях, если:
    # 1. Ключа "name" у объекта "person" нет
    # 2. Ключ "name" есть, но его значение ложно
    print("Name doesn't exist")
"""
"""
num_one = 10
num_two = 5.3

if (num_one > 0 and
   num_two > 0 and
   isinstance(num_one, int) and
   isinstance(num_two, int)):
    print("Both numbers are ints and positive")
else:
    print("One of the number is not supported")
"""
"""
my_number = 21.5

if(type(my_number) is int): #this can be substitude by ISINSTANCE()
    #isinstance(my_number, int)
    print(my_number, 'is integer')
else:
    print(my_number, 'is not an integer') # 21.5 is not an interger"""
"""
my_phone = {
    'price': 200
}

if my_phone.get('brand'):
    print("Phone's brand is", my_phone["brand"])
else:
    print("There is no phone brand")
"""

# INSTUCTION IF elif, порядок следования условий важен, т.к. выполняется
# только одно условие, которое идет первым. В случае если мы хотим,
# чтобы нам вернулись все требуемые условия, а не только первый соответствующее,
# в таком случае следует везде использовать if, тогда пайтон пробежится
# по всем условиям и вернет на все тремуемые нами условия,

"""
if Условие 1:
    Блок кода, выполняемый однократно, если Условие 1 правдиво.
elif Условие 2:
    Блок кода, выполняемый однократно, если Условие 1 ложно, а Условие2
    правдиво.
else:
    Блок кода, выполняемый однократно, если предыдущие условия ложны

"""

# Использование if in function

"""
def nums_info(a, b):
    if (type(a) is not int or type(b) is not int):
        return "One of the arguments is not integer."

    if a >= b:
        return f"{a} greater or equal to {b}"

    return f"{a} smaller that {b}"


print(nums_info(True, 10))  # One of the arguments is not integer.
print(nums_info(10, 2))  # 10 greater or equal to 2
print(nums_info(4, 12))  # 4 smaller that 12

# ================================================
# ELIF

def nums_info(a, b):
    if (type(a) is not int or type(b) is not int):
        info = "One of the arguments is not integer."
    elif a >= b:
        info = f"{a} greater or equal to {b}"

    else:
        info = f"{a} smaller that {b}"
    return info


print(nums_info(True, 10))  # One of the arguments is not integer.
print(nums_info(10, 2))  # 10 greater or equal to 2
print(nums_info(4, 12)) # 4 smaller that 12
"""


# ЗАДАЧА

# 1. Создайте функцию route_info, которой будет передаваться словарь.

# 2. Если в словаре есть ключ distance и его значение - целое число,
# верните строку "Distance to your distination is {distance}".

# 3. Иначе, если в словаре есть ключи speed and time, верните
# строку "Distance to your destination is {speed * time}"

# 4. Иначе верните строку "NO distance info is available"

# 5. Вызовите функцию несоклько раз с разынми аргументами.

# My solution:
"""
trip = {
    # "distance": 1000,
    "time": 3,
    "speed": 150.4
}


def route_info(route_dict):
    if ("distance" in route_dict and isinstance(route_dict["distance"], int)):
        return f"Distance to your distination is {route_dict['distance']} km"

    if (("speed" in route_dict and "time" in route_dict) and
            isinstance(route_dict['speed'], int) and isinstance(route_dict['time'], int)):
        return f"Distance to your destination is {route_dict['speed'] * route_dict['time']} km"

    else:
        return "NO distance info is available"


print(route_info(trip))
"""


# Bogdan's decision

# def route_info(route):
#     if ('distance' in route) and (type(route['distance']) == int):
#         return f"Distance to your destination is {route['distance']}"

#     if ('speed' in route) and ('time' in route):
#         return f"Distance to your destination is {route['speed'] * route['time']}"

#     return "No distace info is avalable..."


# ================================================2 version

"""def route_info(route):
    if ('distance' in route) and (type(route['distance']) == int):
        route_info = f"Distance to your destination is {route['distance']}"

    elif ('speed' in route) and ('time' in route):
        route_info = f"Distance to your destination is {route['speed'] * route['time']}"

    else:
        route_info = "No distace info is avalable..."
    return route_info


print(route_info({'distance': 15}))
# Distance to your destination is 15

print(route_info({'speed': 20, 'time': 3}))
# Distance to your destination is 60


print(route_info({'my_speed': 30}))
# No distace info is avalable...
"""

# Тернарный оператор - 3 операнда - это ВЫРАЖЕНИЕ - ЕГО РЕЗУЛЬТАТ ЗНАЧЕНИЕ

# Переменная = Выражение_1 if Условие else Выражение_2

# Если условие правдиво, тогда выозвращается результат Выражения 1, если условие ложно,
# тогда возвращается результат Выражения 2.

# К примеру в Выражение 1 может быть вызов какой-либо функции, а в Выражении 2 может
# быть вызов другой функции. Вызываться будет первая функция, если условие правдиво, а если
# условие ложно, то вызовется второе выражение.

"""
my_number = 21.5

print("is int") if type(my_number) is int else print(
    "is not int")  # is not int
"""
# Example 2

# Ниже идет вызов 2 функций,
# Мы выполняем проверку, если в словаре img есть ключ 'is_processed', это к примеру
# обозначает, что изображение уже обработано и его необходимо отправить, и потому, мы
# вызываем первую функцию send_img, если этого ключа нет в этом словаре, тогда вызывается
# другая функци.
"""
img = {
    "maksim_img": "1040x2040",
    # 'is_processed': True
}


def send_img(img):
    return img


def process_and_send_img(img):
    return "Image is still in process..."


result = send_img(
    img) if img.get('is_processed') else process_and_send_img(img)

print(result)


# Exmaple 3 Проверка наличия товаров.

product_qty = 10

print('in stock' if product_qty > 0 else 'out of stock')  # in stock

# Example 4

temp = -24

weather = 'hot' if temp > 18 else 'cold'
print(weather) #cold

"""
"""
my_img = ('1920', '1080', True)


print(f"{my_img[0]}x{my_img[1]}") if len(
    my_img) == 2 else print("Incorrect image formatting") 
#Incorrect image formatting

"""

"""my_img = ('1920', '1080')

info = f"{my_img[0]}x{my_img[1]}" if len(
    my_img) == 2 else print("Incorrect image formatting")

print(info) #1920x1080
"""

# Задание
# 1. Переписать выражение выше с использованием операторов if else.
# 2. Сделать так, чтобы при помощи тернарного оператора можно было
# проверить длинну строки. т.е. если длинна строки больше 79 символов,
# то мы печатаем в терминал string is long. иначе пишем string is short.

# My decision

"""my_img = ('1920', '1080')

if len(my_img) == 2:
    print(my_img)
else:
    print("Incorrect image formatting")

# =======================================================

my_str = "Hello"

print("Your string is long") if len(
    my_str) >= 79 else print("Your string is short")


# Bogdan's decision

my_img = ('1920', '1080')

if len(my_img) == 2:
    info = f"{my_img[0]}x{my_img[1]}"
else:
    info = "Incorrect image formatting"

print(info)


# ============================================================

my_str = "Hello,Hello,Hello,Hello,Hello,Hello,Hello,Hello,Hello,Hello,Hello,Hello,Hello,Hello,Hello, "

res = "Your string is long" if len(
    my_str) >= 79 else "Your string is short"


print(res)"""

# Циклы
# Примеры ниже показывают, как цикл может заменить цикличные действия
"""
# Example 1
i = 10

print(i)  # 10
i *= 2

print(i)  # 20
i *= 2

print(i)  # 40
i *= 2

# Example 2

my_fruits = ['apple', 'banana', 'lime']

print(my_fruits[0])  # apple
print(my_fruits[1])  # banana
print(my_fruits[2])  # lime


# Example 3

my_object = {
    'x': 10,
    'y': True,
    'z': 'abc'
}

print(my_object['x'])  # 10
print(my_object['y'])  # True
print(my_object['z'])  # abc
"""
"""Во всех примерах выше, если кол-во эл. превышает, кол-ва имеющихся эл.,
то выдаст ошибку. А, в словаре следует использовать метод get, чтобы
проверить есть эл. или же нет, в таком случае если эл. нет в словаре,
нам вернется None."""


# Циклы используются для перебора элементов последовательностей
# Последовательности - dict, list, tuple, set, range, str - не зависимо
# от того упорядоченная последовательность или же нет, можно пройтись
# по ней циклом.
#
# Типы в Пайтон for ... in and while.


# FOR IN

# for Элемент in Последовательность: # Действия с каждым эл.


"""my_list = [True, 10, 'abc', {}]

for elem in my_list:
    print(elem)  # True, 10, 'abc', {}


# for tuple
video_info = ('1920x1080', True, 27)

for elem in video_info:
    print(elem)  # 1920x1080, True, 27


# for dict

my_object = {
    'x': 10,
    'y': True,
    'z': 'abc'
}

for key in my_object:
    print(key, my_object[key])  # x 10, y True, z abc.

for el in [1, 'abc', True]:
    print(type(el))  # <class 'int'>, <class 'str'>, <class 'bool'>
    print(el)  # 1, abc, True

# При этом перемнная el, доступна вне блока кода, но будет выведено
# последнее значение, в Нашем случе True.

print(el)  # True

print(dir())"""  # ['__annotations__', '__builtins__', '__cached__',
# '__doc__', '__file__', '__loader__', '__name__', '__package__',
# '__spec__', 'date', 'deepcopy', 'el', 'elem',
# 'key', 'mult_by_factor', 'my_list', 'my_object', 'video_info'],

# Как видно в примере выше была создана в глобальной области видимости
# переменна el, поэтому не следует здесь использовать название той
# переменной, которая уже где-то используется у нас в коде, те же
# операции можно выполнять в кортежею,
#

"""my_dict = {'id': 324}

for key in my_dict:
    print(type(key)) #<class 'str'>
    print(key) # id
    print(my_dict[key]) # 324
"""

# Итерация по ключам с значением в словаре.
"""
my_object = {
    'x': 10,
    'y': True
}

for item in my_object.items():
    key, value = item
    print(key, value)  # x 10, y True

# or example below, result will be the same.

for key, value in my_object.items():
    print(key, value)
"""

# For in for SET
"""
video_ids = {1435, 2343, 3455, 4777}

for id in video_ids:
    print(id)  # 1435, 2343, 3455, 4777


my_name = "Maksim"

for letter in my_name:
    print(letter)
    # M
    # a
    # k
    # s
    # i
    # m
for num in range(5):
    print(num)  # 0, 1, 2, 3, 4, используя этот метод, к примеру
    # можно определенное кол-во раз подключиться к серверу.

for odd_num in range(3, 10, 2):
    print(odd_num) #3, 5, 7, 9 
"""
"""my_website = "www.my_web.com"


def get_website(web):
    for key in range(5):
        print(web)


get_website(my_website)
"""

# Задача 1

# 1. Создайте функцию dict_to_list, которая будет конвертировать
# словарь в список кортежей.
# 2. Функция должна принимать словарь, а возвращать список кортежей,
# в каждом кортеже должны быть пары (key, value) из словаря.
# 3. Если значение ключа - целое число, то его нужно умножить на 2
# перед добавлением в кортеж.

# my_goal = {
#     "name": "Maksim",
#     "age": 43,
#     "ocupation": "Software engenere"
# }

"""
def dict_to_list(dict_to_convert):
    list_for_convertion = []

    for key, value in dict_to_convert.items():
        if type(value) == int:
            value *= 2
        list_for_convertion.append((key, value))
    return list_for_convertion


result = dict_to_list({
    "name": "Maksim",
    "age": 43,
    "ocupation": "Software engenere"
})

print(result)
"""

# Задача 2

# 1. Создайте функцию filter_list, которая будет фильтровать список.
# 2. У функции должно быть два параметра - список и тип значения.
# 3. Функция должна вернуть новый список, в котором останется только
# значения того типа, который был передан в вызове функции вторым
# аргументом.
# 4. Функцию можно будет вызвать например так:
# filter_list([35, True, 'abc', 10], int) и получить [35, 10].
# это все следует реализовать используя цикл for... in..., не используя
# встроенную функцию filter.

"""
def filter_list(my_list, type_input):
    new_list = []
    for item in my_list:
        if type(item) == type_input:
            new_list.append(item)

    return new_list
"""
# if isinstance(item, type_input):
# new_list.append(item)  Этот вариант дает нам также True
# [35, True, 10], потому что True является также
# экземпляром класса интеджер, это было сделано изначально
# в Пайтоне, потому, что изначально логического типа в Пайтон
# не было и потому на основании целых чисел создали еще один тип,
# булеан и в нем есть только два значения True -1 and False - 0 и
# потому если мы введем выражение ниже, то во всех случаях мы получим
# True
#
# print(isinstance(True, bool)) - True
# print(isinstance(True, int)) - True
# print(isinstance(True, object)) - True
#
# потому что значением логических типов в Пайтон являются экземплярами
# и класса bool, int, object именно поэтому не рекомендуется
# для решение этой задачи использовать метод isinstance(), потому
# что можно получить неоднозначный результат,


# print(filter_list([35, True, 'abc', 10], int))


"""def filter_list(list_to_filter, int_item):
    def check_element_type(elem):
        # return isinstance(elem, int_item) # [35, True, 10]
        # return type(elem) == int_item  # [35, 10]
        return type(elem) is int_item #Correct version [35, 10]

    return list(filter(check_element_type, list_to_filter))


print(filter_list([35, True, 'abc', 10], int))"""


# using lambda function
"""
def filter_list(list_to_filter, int_item):

    return list(filter(lambda elem: type(elem) is int_item,
                       list_to_filter))


print(filter_list([35, True, 'abc', 10, 22, 33], int))
"""

# Цикл while

# while Условие: - цикл выполняется пока условие правдиво..
# Блок кода, выполняемый на каждой итерации, при этом
# блок кода может быть не выполнен ни разу если условие
# ложно.

# i = 10

# while i < 50:
#     print(i)
#     i += 10
# Переменная i меняется внутри цикла, если мы попытаемся изменять
# эту переменную вне цикла, то мы получим бесконечный цикл в данном
# примере, потому что внутри цикла i не будет меняться,
# 10
# 20
# 30
# 40
"""
while True:
    answer = input("Enter yes or no:")
    if answer == 'no':
        print("You stopped the app!")
        break
    print(answer)
"""

# continue...

"""
random_num = random.randint(1, 5)
num_qty = 0

while True:
    num = int(input("Guess the number from 1 to 5:"))
    num_qty += 1

    if num != random_num:
        print("Try again...")
        continue
    print(
        f"Coungratulation! You could guess it from {num_qty} attempts.The number was {random_num}")
    break
"""

"""Задача: 

1. Создайте цикл, в котором нужно поросить пользователя ввести 
в терминале два числа.

2. Выведите в терминал результат деления первого числа на второе.

3. Выведите ошибку если деление происходит на ноль.

4. После этого спросите пользователя, хочет ли он продолжать yes/no.

5. Если ответ no, то нужно выйти из цикла.

6. Иначе нужно повторить все сначала."""


"""while True:
    print("Insert 2 numbers")
    try:
        first_num = float(input("First number: "))
        second_num = float(input("Second number: "))
    except ValueError as e:
        print(e)
        print("Your must enter numbers!")
        continue
    try:
        sum_of_nums = first_num / second_num
    except ZeroDivisionError:
        print("Can't be devided by 0")
        continue
    print(f"{first_num} / {second_num} = {sum_of_nums}")
    continue_to_culc = input("Do you want to continue Yes or No?")
    if continue_to_culc.lower() == "no":
        print("Your stopped the programm!")
        break"""


# Сокращенный цикл for in.. or list or dict comprehensions.

"""он используется для создания новых последовательностей. 
list, dict, tuple, set

Выражение for Элемент in Последовательность if Условие"""

# Формирование нового списка в обычном FOR IN
#
# В примере ниже, мы должны получить абсолютное значение, т.е.
# абсолютное значение это значение, которое не учитывает знак.
"""
all_nums = [-3, 1, 0, 10, -20, 5]

absolute_nums = []

for num in all_nums:
    absolute_nums.append(abs(num))

print(absolute_nums)  # [3, 1, 0, 10, 20, 5]

print(all_nums)  # [-3, 1, 0, 10, -20, 5]

# ниже идет сокращенный FOR IN ДЛЯ СПИСКОВ

all_nums = [-3, 1, 1, 1, 0, 10, -20, 5]

absolute_nums = [abs(num) for num in all_nums]

print(absolute_nums)  # [3, 1, 1, 1, 0, 10, 20, 5]

print(all_nums)  # [-3, 1, 1, 1, 0, 10, -20, 5]

abs_tupple_nums = (abs(num) for num in all_nums)
print(tuple(abs_tupple_nums))  # (3, 1, 1, 1, 0, 10, 20, 5)

abs_set_nums = (abs(num) for num in all_nums)
print(set(abs_set_nums))  # {0, 1, 3, 5, 10, 20}
"""

# Формирование нового списка с фильтрацией в обычном FOR IN.

"""
all_nums = [-3, 1, 0, 10, -20, 5]

positive_nums = []

for num in all_nums:
    if num > 0:
        positive_nums.append(num)

print(positive_nums)  # [1, 10, 5]

print(all_nums)  # [-3, 1, 0, 10, -20, 5]
"""


# Short version:
"""
all_nums = [-3, 1, 0, 10, -20, 5]

positive_nums = [num for num in all_nums if num > 0]
# При этом условие для фильтрации опционально, если условия нет, 
# то кол-во эл. в результирующем списке. Будет такое же как и в 
# оригинале. Если условие есть, то мы можем некоторые эл. отфильтровать.
# те эл. которые не удовлетворяют этому условию 

print(positive_nums)  # [1, 10, 5]

print(all_nums) #[-3, 1, 0, 10, -20, 5]
"""

# Формирование нового набора в обычном FOR IN.

"""my_set = {1, 10, 15}

new_set = set()

for val in my_set:
    new_set.add(val * val)

print(new_set)  # {1, 100, 225}

print(my_set)  # {1, 10, 15}


# short version

my_set = {1, 10, 15}

new_set = {num * num for num in my_set}

print(my_set)

print(new_set)
"""

# Version number 3
"""
my_scores = {
    'a': 10,
    'b': 7,
    'c': 14
}

scores = {}

for key, value in my_scores.items():
    scores[key] = value * 10

print(scores)  # {'a': 100, 'b': 70, 'c': 140}

print(my_scores)  # {'a': 10, 'b': 7, 'c': 14}

# Short version

my_scores = {
    'a': 10,
    'b': 7,
    'c': 14
}

scores = {key: value * 10 for key, value in my_scores.items()}

print(scores) #{'a': 100, 'b': 70, 'c': 140}

print(my_scores) #{'a': 10, 'b': 7, 'c': 14}

"""
"""
my_scores = {
    'a': 10,
    'b': 7,
    'c': 14
}

# That is how we can make set from a dict, also we may make a list
# from a dict replacing {} by [] in the expression below.

scores = {value * 10 for key, value in my_scores.items()}

print(scores)  # {140, 100, 70}
"""
"""my_dict = ["Hi", True, 2444, False, [], "Got_you"]

my_list = {key: value * 2 for key, value in enumerate(my_dict)}

print(my_list)  
#{0: 'HiHi', 1: 2, 2: 4888, 3: 0, 4: [], 5: 'Got_youGot_you'}"""

# Exercise #1

"""1. Создайте словарь с несколькими ключами, значения которых 
должны быть типа str.

2. создайте новый словарь на основании существующего,
в котором значения всех ключей должны быть в верхнем регистре.

3. Результирующий словарь выведите в терминал. """
"""
my_dict = {
    "name": "maksim",
    "ocupation": "moftware engineer",
    "employment_status": "employeed"
}

new_dict = {}

for key, value in my_dict.items():
    new_dict[key] = value.upper()

print(new_dict)


# ================================================

my_dict = {
    "name": "maksim",
    "ocupation": "moftware engineer",
    "employment_status": "employeed"
}

new_dict = {key: value.capitalize() for key, value in my_dict.items()}


print(new_dict)
"""

# Exercise # 2

"""1. Создайте список с элементами типа str.

2. Из этого списка создайте новый списко, в котором останутся
только строки, длина которых больше 3.

3. Результирующий список выведите в терминал. """

"""
my_list = ["Maksim", 'Hi', "Anastasiya", 'L']

new_list = []

for item in my_list:
    if len(item) > 3:
        new_list.append(item)

print(new_list)

# =================================================


my_list = ["Maksim", 'Hi', "Anastasiya", 'L']

new_list = [index for index in my_list if len(index) > 3]


print(new_list)
"""


# Генераторы в сокращенном FOR IN

"""squares = (num * num for num in range(6))

print(squares)  # <generator object <genexpr> at 0x7afa57ff8110>
hight_digt = []
for num in squares:
    if num > 2:
        hight_digt.append(num * 2)

print(hight_digt)
print(type(squares))  # <class 'generator'>

for num in squares:
    print(num)"""
# 0
# 1
# 4
# 9
# 16
# 25


"""nums = [3, 4, 5]

gen = (num * num for num in nums)

square = tuple(gen)

print(square)  # (9, 16, 25)

print(type(square))  # <class 'tuple'>"""


# Что нам дает Генератор? Главное его преимущество это размер.

# from sys import getsizeof -

# Т.е мы из встроенного модуля sys импортируем встроенную функцию getsizeof,
# с помощью этой функции мы можем получить
# размер объекта, вызываем ниже эту функцию и ей передаем объект,
# к примеру squares_gen, и мы получаем размер объекта 112,
# т.е. то сколько места занимает объект в памяти, так вот мы формируем
# генератор squares_gen, то что после него указаны круглые скобки
# и говорит нам о том, что мы создаем генератор, т.е. объект класса
# generator и здесь мы формируем генератор из большого кол-ва эл. в
# нашем случае 10_000 эл. и каждый эл. мы умножаем на него же, возводим
# во вторую степень, так вот в результате размер такого генератора
# будет небольшой.
"""
squares_gen = (num * num for num in range(10000))

print(getsizeof(squares_gen))  # 112

print(type(squares_gen))  # <class 'generator'>
"""

# если мы сделаем тоже самое, что и выше и сформируем список
# используя квадратные скобки, т.е. список из 10_000 эл. то размер
# такого списка будет уже намного больше нежели размер генератора. т.е
# если нам необходимо выполнять действия с большими массивами данных и
# перебирать эти массивы, то имеет смысл создвать генираторы и потом
# по этим генераторам выполнять итерацию, для того чтобы выполнять
# разные действия с эл. в генераторе. Потому что генераторы,
# существенно позволяют сэканомить место, которое выделяется под
# объект..

"""squares_list = [num * num for num in range(10000)]

print(getsizeof(squares_list))  # 85176

print(type(squares_list))  # <class 'list'>
"""
# При этом доступ к эл. через квадратные скобки не доступен,
# но можно провести итерацию при помощи цикла и получить нужный нам
# эл как показано ниже.

"""squares_gen = (num * num for num in range(10000))

print(getsizeof(squares_gen))  # 208


for elem in squares_gen:
    print(elem) #0
                # 1
                # 4
                # 9
                # 16
                # 25
                # 36
                # 49
                # 64
                # 81
                # 100
    if elem == 100:
        break

squares_list = [num * num for num in range(10000)]

print(getsizeof(squares_list))  # 85176
"""


# КЛАССЫ И ОБЪЕКТЫ
# КЛАССЫ ЭТО ШАБЛОНЫ ДЛЯ ОБЪЕКТОВ. НА ОСТНОВАНИИ ШАБЛОНОВ
# СОЗДАЮТСЯ ЭКЗЕМПЛЯРЫ КЛАССОВ, при этом класс может быть один
# а экземпляров сколько угодно на основании одного класса.
# Экземпляры могут иметь собственные атрибуты и в таком случае
# значение этих атрибутов можно изменять независимо от других
# экземпляров, потому что они принадлежат к экземпляру того или
# иного класса. Если к примеру мы создаем 10 экземпляры определенного
# класса и у каждого из них есть свои собственные атрибуты, то эти
# атрибуты привязаны только к конкретному экземпляру и независимы
# от др. экземп. и изменять собственные атрибуты можно только путем
# обращения к определенному экземп. класса.
# ЭЗЕМПЛЯРЫ НАСЛЕДУЮТ АТРИБУТЫ КЛАССОВ, т.е. если например на уровне
# класса определены методы, то методы могут наследоваться всему экземп.
# этого класса.
# Классы созаются используя ключевое слово class.

"""
class Car:
    def move(self):
        print("Car is moving")

    def stop(self):
        print("Car stopped")


my_car = Car()

print(type(my_car))  # <class '__main__.Car'>

print(isinstance(my_car, Car))  # True

my_car.move()  # Car is moving

my_car.stop()  # Car stopped

print(isinstance(my_car, object))  # True

print(dir(my_car))  # ['__class__', '__delattr__', '__dict__',
# '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
# '__getattribute__', '__getstate__', '__gt__', '__hash__',
# '__init__', '__init_subclass__', '__le__', '__lt__',
# '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
# '__repr__', '__setattr__', '__sizeof__',
# '__str__', '__subclasshook__', '__weakref__', 'move', 'stop']
my_second_car = Car()

print(my_car == my_second_car)  # False

print(id(my_car))  # 138132961966608
print(id(my_second_car))  # 138132962362128


Car.move(my_car) #Car is moving

"""

# СОЗДАНИЕ КЛАССА С МЕТОДОМ.

# __INIT__

"""
class Comment:
    def __init__(self, text):
        self.text = text
        self.votes_qty = 0

    def upvote(self):
        self.votes_qty += 1


first_comment = Comment("First comment")

print(first_comment.text)  # First comment
print(first_comment.votes_qty)  # 0
print(first_comment.__dict__) #{'text': 'First comment', 'votes_qty': 0}
"""

# СОБСТВЕННЫЕ АТРИБУТЫ ЭКЗЕМПЛЯРОВ ОПРЕДЕЛЯЮТСЯ С ПОМОЩЬЮ ФУНКЦИИ __init__
# это ключевая функция - конструктор.
#


"""class Comment:
    def __init__(self, text):
        self.text = text
        self.votes_qty = 0

    def upvote(self, qty):
        self.votes_qty += qty


first_comment = Comment("First comment")


print(first_comment.text)  # First comment
print(first_comment.votes_qty)  # 0

# first_comment.upvote()

first_comment.upvote(5)  # вызываем функцию и ниже увеличевается значение

print(first_comment.votes_qty)  # 5
"""


# class Comment:
#     def __init__(self, text):
#         self.text = text
#         self.votes_qty = 0

#     def upvote(self, qty):
#         self.votes_qty += qty


# my_comment = Comment("My comment")

# my_comment.upvote = 10

# print(my_comment.__dict__)

# second_comment = Comment("Second comment")
# second_comment.upvote(2)
# print(second_comment.votes_qty)
"""
class Comment:
    def __init__(self, text, initial_votes_qty=0):
        self.text = text
        self.votes_qty = initial_votes_qty
# text and votes_qty это собственные атрибуты, конкретного экземпляра,
# и их можно изменять, а методы ниже наследуются всемы экземплярами класса.
    def upvote(self, qty):
        self.votes_qty += qty

    def reser_votes_qty(self):
        self.votes_qty = 0


my_comment = Comment("My comment")

my_comment.upvote(10)
print(my_comment.votes_qty)  # 10

my_comment.upvote(20)
print(my_comment.votes_qty)  # 30


my_comment.reser_votes_qty()
print(my_comment.votes_qty)  # 0
"""

# Задача.

# 1. создайте класс Image

# 2. У каждого экземпляра класса Image должно быть три собственных атрибута
# -resolution
# -title
# -extension

# 3. В классе должен быть метод resize, с помощью которого можно
# поменять разрешение изображения. Вы должни просто менять значение
# атрибута resolution.

# 4. создайте несколько экземпляров класса Image и вызовите метод resize.

# Мое решение

"""class Image:
    def __init__(self, resolution, title="my_image:", extension="com"):
        self.resolution = resolution
        self.title = title
        self.extension = extension

    def resize(self, resize_resolution):
        self.resolution = resize_resolution

    def rename(self, rename_title):
        self.title = rename_title

    def change_ext(self, change):
        self.extension = change


my_image = Image("1040x2040", "Photosname")

print(my_image.title)
print(my_image.extension)
print(my_image.resolution)
print(my_image.title)

my_image.resize("780x1200")

print(my_image.resolution)

my_image.rename("Another photo")

print(my_image.title)


my_image.change_ext("net")

new_ext = my_image.extension

print(
    f"The file named {my_image.title} \
has {my_image.resolution} resolution and {new_ext} extention")
"""


"""class Image:
    def __init__(self, title, resolution, extension):
        self.title = title
        self.resolution = resolution
        self.extension = extension

    def change_resolution(self, resolution_change):
        self.resolution = resolution_change

    def change_title(self, new_title):
        self.title = new_title

    def change_extension(self, extension_change):
        self.extension = extension_change

    def __str__(self):
        return f"{self.title}, {self.resolution}, {self.extension}"


# Создание объекта Image
my_image = Image('my_dog', '1040x2040', 'jpg')

# Вывод исходного изображения
print(my_image)

# Изменение свойств изображения
new_title = my_image.change_title("my_cat")
new_resolution = my_image.change_resolution("2000x3000")
new_extension = my_image.change_extension('jpeg')

# Вывод измененных свойств
print(f"My new animal is {new_title}. Photo size is {new_resolution} \
and the extension is {new_extension}")"""


# Методы экземпляров

# Привязанные методы BOUND METHODS

# Метод считается привязанный если первый параметр self.

# Ниже показано как нужно вызывать привязанные методы

# first_comment.uppote()
# Comment.upvote(first_comment)


# Статические методы

# class Comment:
#     def __init__(self, text):
#         self.text = text

#     @staticmethod
#     def merge_comments(first, second):
#         return f"{first} {second}"


# my_comment = Comment("My comment")

# m_1 = Comment.merge_comments("Thanks!", "Excellent.")
# print(m_1) #Thanks! Excellent.

# m_2 = Comment.merge_comments("Great", "OK")
# print(m_2) #Thanks! Excellent.

# Статические методы не являются привязанными методами, т.е. их можно
# вызывать без контекста, без привязки к определенному экземпляру класса.
# их можно вызывать независимо. Такие методы создаются тогда, когда
# нам необходимо выполнять определенные действия на уровне классов в целом,
# без привязки к определенному экземпляру класса


# Атрибуты класса.
"""
class Comment:
    total_comments = 0

    def __init__(self, text):
        self.text = text
        self.votes_qty = 0
        Comment.total_comments += 1


first_comment = Comment("First comment")

print(Comment.total_comments)  # 1

second_comment = Comment("Second comment")

print(Comment.total_comments)  # 2

print(first_comment.total_comments)  # 2

first_comment.total_comments = 10
print(first_comment.__dict__)
# {'text': 'First comment', 'votes_qty': 0, 'total_comments': 10}

print(Comment.__dict__)
# {'__module__': '__main__', 'total_comments': 2,
# '__init__': <function Comment.__init__ at 0x77b169e79b20>,
# '__dict__': <attribute '__dict__' of 'Comment' objects>,
# '__weakref__': <attribute '__weakref__' of 'Comment' objects>, '__doc__': None}.

print(Comment.total_comments)  # 2

print(first_comment.total_comments)  # 10

# Таким же образом можно добавлять на уровне класса любое кол-во
# собственных атрибутов, но при этом к ним можно обращаться из экземпляров,
# но изменить на уровне экземпляра значения токого атрибута нельзя.

# Вопрос: Можем ли бы изменить напрямую значение атрибута, пробуем
# ниже.
Comment.total_comments = 10

print(Comment.total_comments)  # 10
print(first_comment.total_comments)  # 10
"""
# Мы выдим 10 и 10 выше, это означает, что мы обратились к атрибуту
# класса, через класс и присвоили новое значение, то это новое значение
# теперь будет доступно и на уровне класса и для всех экземпляров, хотя
# мы изменили значение только в одном месте. т.е здесь изменения отражаются
# на всех экземпляров класса.

# обычно таким образом с помощью атрибутов классов добавляются
# определенные константы класса, для того, чтобы их можно было использовать
# например в таких методах либо в функциях конструкторах. и как показано
# выше их можно изменять непоследственно в одной из функции непосредственно
# в классе - это допускается.

# Магические мтеоды в классах.


"""class Comment:
    def __init__(self, text):
        self.text = text
        self.votes_qty = 0

    def upvote(self):
        self.votes_qty += 1

    def __add__(self, other):
        return (f"{self.text} {other.text}",
                self.votes_qty + other.votes_qty)


firs_comment = Comment("First comment")
firs_comment.upvote()
second_comment = Comment("Second comment")
second_comment.upvote()

# Остановился здесь Раздел 41: Магические методы.


# Декораторы.
def is_user_authenicated():
    return False


def check_user_auth(fn):
    def wrapper(*args, **kwargs):
        if is_user_authenicated():
            print("User is authenticated!")
            return fn(*args, **kwargs)
        else:
            raise Exception("User is NOT authenticated...")

    return wrapper


@check_user_auth
def do_sensitive_job():
    # Do some tasks only if user is authenticated
    print("Results of some sensitive tasks.")

try:
    do_sensitive_job()
except Exception as e:
    print(e)"""


# JSON -Javascript Object Notation - Формат обмена данными и формат файлов - это формат обмена
# данными между компьютерами, также это формат хранения данных,
# так как очень легко хранить данные в формате джейсон - ключ - значение
#
# Допустимые типы значений в JSON
# string, number, JSON object, boolean, array, null
#
# Передача данных в формате джейсон происходит в виде строки
# {"id":235, "brand": "Nike", "status":{"isForSale":true}}.

# import json


"""json_str = '{"id": 235, "brand": "Nike", "status": {"isForSale":true}}'

sneakers = json.loads(json_str)  # loads is atribute of json

print(type(sneakers))

print(sneakers['brand'])  # Nike
# True - converted from JS format to Python - from true to True.
print(sneakers['status']['isForSale'])

# Formating from dict to json using method json.dumps below.

my_dict = {
    'id': 235,
    'brand': 'Nike',
    'qty': 84,
    'status': {
        'isForSale': True
    }
}

my_dict_to_json = json.dumps(my_dict)
print(my_dict_to_json)
# {"id": 235, "brand": "Nike", "qty": 84, "status": {"isForSale": true}}

# Форматирование результирующего JSON
print('')
json_str = '{"id": 235, "brand": "Nike", "status": {"isForSale":true}}'

sneakers = json.loads(json_str)
json.dumps(sneakers, indent=1)  # добавляет один отступ между эл.
print(sneakers)"""

# Конвертация типов Python to type JSON.

# Python - json
# str - String
# int - Number
# float - Number
# True - true
# False - false
# None - null
# dict - Object
# list - Array
# tuple - Array


# import json

"""json_array = [{"a": 1}, {"b": 2}]

my_list = json_array.loads(json_array)

print(my_list)"""


# Задача

# 1. Создайте любой словарь, используя ключи с значениями разных типов.

# 2. Конвертируйте словарь в JSON.

# 3. Результирующий JSON выведите в терминал.

# 4. Выведите в терминал тип результирующего значения.


"""my_dict = {
    'name': 'Maksim',
    'age': 43,
    'maried_status': True,
    'family': {
        'wife': ['Anastasiya', 35],
        'daughers': {
            'Yelizaveta': 12,
            'Yekaterina': 11,
        }
    },
}

# Convert dictionary to JSON string
my_dict_to_json = json.dumps(my_dict, indent=4)
print(my_dict_to_json)

# Print the type of JSON string
print(type(my_dict_to_json))

# Convert JSON string back to dictionary
back_to_dict = json.loads(my_dict_to_json)
print(back_to_dict)

# Print the type of the dictionary
print(type(back_to_dict))
"""
# Result:
# {
# "name": "Maksim",
# "age": 43,
# "maried_status": true,
# "family": {
#     "wife": [
#         "Anastasiya",
#         35
#     ],
#     "daughers": {
#         "Yelizaveta": 12,
#         "Yekaterina": 11
#     }
# }
# }
#     < class 'str' >
#     {'name': 'Maksim', 'age': 43, 'maried_status': True, 'family': {
#         'wife': ['Anastasiya', 35], 'daughers': {'Yelizaveta': 12, 'Yekaterina': 11}}}
#     < class 'dict' > .


# Встроенные модули для рнаботы с файлами. OS(является пакетом,
# который содержит различные модули, в том числе path) and PATHLIB(объектно-ориетнированный подход к работе с файлами)
# Примеры показанные ниже.


# from os import path

# print(path.abspath('.'))
# # c:\Users\Windows 11\Desktop\python

# print(type(path))
# # <class 'module'>

# # Выше указан функциональный подход, а ниже объектно-ориентированный подход.


# print(Path('.').absolute())
# # c:\Users\Windows 11\Desktop\python

# print(type(Path)) 
# # <class 'type'>



# =======================================================

# Ниже показан способ формирования Списка с методами не включая в него магические методы. 
"""
from pathlib import Path

file_path = Path('test.txt')

print([m for m in dir(file_path) if not m.startswith('_')])
"""

# Путь к текущей директории(cwd - current working directory)-

# from pathlib import Path

# print(Path.cwd())  # c:\Users\Windows 11\Desktop\python


# Формирование путей на mac and unix

# from pathlib import Path

# print(Path('usr').joinpath('local').joinpath('bin'))  # usr\local\bin

# print(Path('usr') / 'local'/'bin')  # usr\local\bin

# #for Windows

# print(Path('C:/').joinpath('Users').joinpath('maksim'))  # C:\Users\maksim

# print(Path('C:/') / 'Users' / 'maksim')  # C:\Users\maksim

# #Проверка присутствия директории или файла

# from pathlib import Path

# print(Path('app.py').exists())
# #True

# print(Path('/Users/Windows 11/Desktop/python/python/bogdan.py').exists())
# #True

# print(Path('other.py').exists())
# #False

#Директория ли файл

# from pathlib import Path

# print(Path('app.py').is_file())
# #True

# print(Path('../python').is_file())
# #False

# print(Path('../python').is_dir())
# #True

# from pathlib import Path

# for f in Path('.').iterdir():
#     print(f)  
# .git
# app.py
# python


# Создание и удаление папок в директории

"""from pathlib import Path

# /Users/Windows 11/Desktop/python/python/bogdan.py

my_dir = Path('/Users')/ 'Windows 11'/'Desktop'/'python'/'python'/'my_new_folder'

if not my_dir.exists():
    my_dir.mkdir() 
#создалась новая папка в текущей директории.

if my_dir.exists():
    my_dir.rmdir()#Удалили эту директорию."""

# Отправка имейлов

from email.message import EmailMessage
import smtplib
from string import Template
from pathlib import Path

my_email = EmailMessage()

html_template = Template(Path("templates/index.html").read_text())
html_content = html_template.substitute({'name': 'Maksim', 'date': 'tomorrow'})

my_email['form'] = 'Maksim'
my_email['to'] = 'test@gmail.com'
my_email['subject'] = 'Hello from Python'
my_email.set_content(html_content, 'html')

with smtplib.SMTP(host='localhost', port=2525) as smtp_server:
    smtp_server.ehlo()
    smtp_server.starttls()
    smtp_server.login('username', 'password')
    smtp_server.send_message(my_email)
    print('Email was sent!')